'use strict';

/*jshint camelcase: false , quotmark: false */

/**
 * @ngdoc function
 * @name blueprintApp.controller:MainCtrl
 * @description
 * # MainCtrl
 * Controller of the blueprintApp
 */
angular.module('blueprintApp')
  .controller('MainCtrl', ['$scope','$q','es','portalConfig','d3',function($scope,$q, es, portalConfig, d3) {

	var REACT_PREFIX = 'REACT_';
	var REACT_FEATURE = 'pathway';
	
    var pageNum = 1;
    var perPage = 50;
    var experimentLabels = ['Bisulfite-Seq','DNase-Seq','Gene Exp (RNA-Seq)','Transcript Exp (RNA-Seq)'];

    var fetchedTreeData;
    var lastSearchMode;

    $scope.info = '<p><a href="http://www.blueprint-epigenome.eu/"><img src="http://dcc.blueprint-epigenome.eu/img/blueprint.png" style="float:left;height:50px;margin-right:20px;"></a>BLUEPRINT is a high impact FP7 project aiming to produce a blueprint of haemopoetic epigenomes. Our goal is to apply highly sophisticated functional genomics analysis on a clearly defined set of primarily human samples from healthy and diseased individuals, and to provide at least 100 <a href="http://ihec-epigenomes.org/research/reference-epigenome-standards/" title="IHEC reference epigenome standards">reference epigenomes</a> to the scientific community. This resource-generating activity will be complemented by research into blood-based diseases, including common leukaemias and autoimmune disease (Type 1 Diabetes), by discovery and validation of epigenetic markers for diagnostic use and by epigenetic target identification.This may eventually lead to the development of novel and more individualised medical treatments. This website will provide links to the data &amp; primary analysis generated by the project.</p>'; 

    $scope.dataRelease = '[Dev without config]';
    $scope.dataDesc = '[Dev without config]';
    if(portalConfig.dataRelease) {
        $scope.dataRelease = portalConfig.dataRelease;
    }
    if(portalConfig.dataDesc) {
        $scope.dataDesc = portalConfig.dataDesc;
    }
    $scope.searchButtonText = "Search";
    $scope.found = "";
    $scope.samplesOnt = [];
    $scope.samples = [];
    $scope.donors = [];
    $scope.labs = [];
    $scope.analyses = [];
    $scope.experimentLabels = [];
    $scope.depth=null;
    $scope.histoneMap = {};
    $scope.bisulfiteSeq = [];
    $scope.rnaSeqG = [];
    $scope.rnaSeqT = [];
    $scope.chipSeq = [];
    $scope.dnaseSeq = [];
    $scope.treedata = null;
    $scope.rangeQuery = [];
    $scope.ensemblGeneId = null;
    $scope.geneQuery = null;
    $scope.pathwayQuery = null;
    $scope.display = 'compact';
    $scope.chromosomes = [{n:1,c:"chr",f:"images/GRCh38_chromosome_1.svg"},
                    {n:2,c:"chr",f:"images/GRCh38_chromosome_2.svg"},
                    {n:3,c:"chr",f:"images/GRCh38_chromosome_3.svg"},
                    {n:4,c:"chr",f:"images/GRCh38_chromosome_4.svg"},
                    {n:5,c:"chr",f:"images/GRCh38_chromosome_5.svg"},
                    {n:6,c:"chr",f:"images/GRCh38_chromosome_6.svg"},
                    {n:7,c:"chr",f:"images/GRCh38_chromosome_7.svg"},
                    {n:8,c:"chr",f:"images/GRCh38_chromosome_8.svg"},
                    {n:9,c:"chr",f:"images/GRCh38_chromosome_9.svg"},
                    {n:10,c:"chr",f:"images/GRCh38_chromosome_10.svg"},
                    {n:11,c:"chr",f:"images/GRCh38_chromosome_11.svg"},
                    {n:12,c:"chr",f:"images/GRCh38_chromosome_12.svg"},
                    {n:13,c:"chr",f:"images/GRCh38_chromosome_13.svg"},
                    {n:14,c:"chr",f:"images/GRCh38_chromosome_14.svg"},
                    {n:15,c:"chr",f:"images/GRCh38_chromosome_15.svg"},
                    {n:16,c:"chr",f:"images/GRCh38_chromosome_16.svg"},
                    {n:17,c:"chr",f:"images/GRCh38_chromosome_17.svg"},
                    {n:18,c:"chr",f:"images/GRCh38_chromosome_18.svg"},
                    {n:19,c:"chr",f:"images/GRCh38_chromosome_19.svg"},
                    {n:20,c:"chr",f:"images/GRCh38_chromosome_20.svg"},
                    {n:21,c:"chr",f:"images/GRCh38_chromosome_21.svg"},
                    {n:22,c:"chr",f:"images/GRCh38_chromosome_22.svg"},
                    {n:"X",c:"chr",f:"images/GRCh38_chromosome_X.svg"},
                    {n:"Y",c:"chr",f:"images/GRCh38_chromosome_Y.svg"},
                    {n:"MT",c:"chr",f:"images/GRCh38_chromosome_MT.svg"}
                  ];

    $scope.results = null;
    
	$scope.subtotals = {
		options: {
			chart: {
				type: 'pieChart',
				height: 475,
				width: 400,
				margin: {
					top: 0,
					right: 0,
					bottom: 0,
					left: 0
				},
				x: function(d) {return d.key;},
				y: function(d) {return d.y;},
				//showLegend: false,
				showLabels: true,
				donut:true,
				title: "Donors & Samples",
				labelsOutside: true,
				labelSunbeamLayout: true,
				labelType: "value",
				transitionDuration: 500,
				labelThreshold: 0.01,
				valueFormat: d3.format('d')
			},
		},
		data: [
			{
				key: "Loading",
				y: 1
			},
		],
	};
    
	//Format function for the tooltip values column
	var valueFormatter = function(d,i) {
		return d;
	};
	
	//Format function for the tooltip header value.
	var headerFormatter = function(d) {
		return d;
	};
	
	var keyFormatter = function(d, i) {
		return d;
	};
	
	var analysisPieTooltipGenerator = function (d) {
		if (d === null) {
			return '';
		}
		
		var headerEnabled = undefined;
		
		var table = d3.select(document.createElement("table"));
		if(headerEnabled) {
			var theadEnter = table.selectAll("thead")
				.data([d])
				.enter().append("thead");
			
			theadEnter.append("tr")
				.append("td")
				.attr("colspan", 3)
				.append("strong")
				.classed("x-value", true)
				.html(headerFormatter(d.value));
		}
		
		var tbodyEnter = table.selectAll("tbody")
			.data([d])
			.enter().append("tbody");
		
		var trowEnter = tbodyEnter.selectAll("tr")
			.data(function(p) { return p.series; })
			.enter()
			.append("tr")
			.classed("highlight", function(p) { return p.highlight; });
		
		trowEnter.append("td")
			.classed("legend-color-guide",true)
			.append("div")
			.style("background-color", function(p) { return p.color; });
		
		trowEnter.append("td")
			.classed("key",true)
			.html(function(p, i) { return keyFormatter(d.data.desc, i); });
		
		trowEnter.append("td")
			.classed("value",true)
			.html(function(p, i) { return valueFormatter(p.value, i); });
		
		trowEnter.selectAll("td").each(function(p) {
			if (p.highlight) {
				var opacityScale = d3.scale.linear().domain([0,1]).range(["#fff",p.color]);
				var opacity = 0.6;
				d3.select(this)
				.style("border-bottom-color", opacityScale(opacity))
				.style("border-top-color", opacityScale(opacity))
				;
			}
		});
		
		var html = table.node().outerHTML;
		if(d.footer !== undefined) {
			html += "<div class='footer'>" + d.footer + "</div>";
		}
		return html;
	};
	
	$scope.analysisSubtotals = {
		options: {
			chart: {
				type: 'pieChart',
				height: 475,
				width: 400,
				margin: {
					top: 0,
					right: 0,
					bottom: 0,
					left: 0
				},
				x: function(d) {return d.key;},
				y: function(d) {return d.y;},
				showLabels: true,
				donut:true,
				title: "Analysis",
				labelsOutside: true,
				labelSunbeamLayout: true,
				labelType: "value",
				tooltip: {
					contentGenerator: analysisPieTooltipGenerator,
				},
				legend: {
					margin: {
						left: 3,
					},
					//key: function(d) { console.log(d) },
				},
				transitionDuration: 500,
				labelThreshold: 0.01,
				valueFormat: d3.format('d')
			},
			//caption: {
			//	enable: true,
			//	text: 'Analysis',
			//	css: {
			//		textAlign: 'center'
			//	}
			//}
		},
		data: [
			{
				key: "Loading",
				y: 1
			},
		]
	};
    
    // If we set this to 1, we separate broad from narrow peaks
    var CSpeakSplit;

	var getAnalyses = function() {
		if($scope.analyses.length === 0) {
			var deferred = $q.defer();
			es.search({
				size: 10000000,
				index: 'metadata',
				body: {
					query: {
						filtered: {
							filter: {
								bool: {
									must: [
										{exists : { field : 'experiment_id' }},
										{exists : { field : 'analysis_id' }}
									]  
								}
							}
						}
					}
			
				}
			},function(err,resp){
				if(typeof(resp.hits.hits) !== undefined) {
					// Now, the analysis subtotals
					var numDlatHyper = 0;
					var numDlatHypo = 0;
					var numDlatOther = 0;
					
					var numCSbroad = 0;
					var numCSnarrow = 0;
					
					var numExpG = 0;
					var numExpT = 0;
					
					var numRReg = 0;
					var numAnOther = 0;
					
					resp.hits.hits.forEach(function(d) {
						d._source._type = d._type;
						switch(d._type) {
							case 'dlat.m':
								switch(d._source.mr_type) {
									case 'hyper':
										numDlatHyper++;
										break;
									case 'hypo':
										numDlatHypo++;
										break;
									default:
										numDlatOther++;
										break;
								}
								
								break;
							case 'pdna.m':
								if(d._source.analysis_id.indexOf('_broad_')!=-1) {
									numCSbroad++;
								} else {
									numCSnarrow++;
								}
								break;
							case 'exp.m':
								numExpG++;
								numExpT++;
								break;
							case 'rreg.m':
								numRReg++;
								break;
							default:
								numAnOther++;
						}
						$scope.analyses.push(d._source);
					});
					
					var analysisSubtotals = [
						{
							key: 'Hyper-m regions',
							desc: 'Hyper-methylated regions',
							y: numDlatHyper
						},
						{
							key: 'Hypo-m regions',
							desc: 'Hypo-methylated regions',
							y: numDlatHypo
						},
					];
					
					if(numDlatOther > 0) {
						analysisSubtotals.push({
							key: 'Other m regions',
							desc: 'Other methylated regions',
							y: numDlatOther
						});
					}
					
					analysisSubtotals.push(
						{
							key: 'CS broad',
							desc: 'ChIP-Seq (broad peaks)',
							y: numCSbroad
						},
						{
							key: 'CS narrow',
							desc: 'ChIP-Seq (narrow peaks)',
							y: numCSnarrow
						},
						{
							key: 'Gene exp',
							desc: 'Gene expression',
							y: numExpG
						},
						{
							key: 'Transcript exp',
							desc: 'Transcript expression',
							y: numExpT
						},
						{
							key: 'Chrom Acc',
							desc: 'Chromatin accessibility',
							y: numRReg
						}
					);
					
					if(numAnOther > 0) {
						analysisSubtotals.push({
							key: 'Other',
							desc: 'Other',
							y: numAnOther
						});
					}
					
					$scope.analysisSubtotals.data = analysisSubtotals;
					
					deferred.resolve();
				} else {
					return deferred.reject(err);
				}
			});
			return deferred.promise;
		}
	};

    var getLabs = function() {
      if($scope.labs.length===0) {
        var deferred = $q.defer();
        es.search({
          size:100000,
          index: 'sample-tracking-data',
          body:{
              query : {
                filtered : {
                    filter : {
                        bool:{
                          must:[
                              {exists : { field : 'experiment_id' }},
                              // {exists : { field : 'analized_sample_id' }}
                              {exists : { field : 'experiment_type' }}
                          ]  
                        }
                        
                    }
                }
            }
        
          }
        },function(err,resp){
        
          if(typeof(resp.hits.hits) !== 'undefined'){
            var histones = [];
            var histoneMap = {};
            resp.hits.hits.forEach(function(d) {
              var  l = {};
              l.type  = d._type;
              l.sample_id = d._source.analyzed_sample_id;
              l.experiment_id = d._source.experiment_id;
              l.experiment_type = d._source.experiment_type;
              l.features = d._source.features;
              if(l.experiment_type.indexOf('Histone ')===0) {
                var histone = l.features.CHIP_ANTIBODY.value;
                var normalizedHistone = histone.replace(/[.]/g,'_');
                
                // Registering new histones
                if(!(normalizedHistone in histoneMap)) {
		  histoneMap[normalizedHistone] = null;
		  histones.push(histone);
		}
              }
        
              if(typeof(l.analyses) === 'undefined'){
                l.analyses = [];
                $scope.analyses.forEach(function(d){
                  if (d.experiment_id == l.experiment_id){
                      l.analyses.push(d.analysis_id);
                  }
                });
              }
              $scope.labs.push(l);
            });
            
            // Now, map the histones and generated the labels
            $scope.experimentLabels = angular.copy(experimentLabels);
            var iHis = $scope.experimentLabels.length;
            histones.sort().forEach(function(histone) {
              var normalizedHistone = histone.replace(/[.]/g,'_');
              histoneMap[normalizedHistone] = iHis;
              
              if(CSpeakSplit) {
                // It uses two slots
                $scope.experimentLabels.push(histone+' (peaks)');
                $scope.experimentLabels.push(histone+' (broad peaks)');
                iHis+=2;
              } else {
                $scope.experimentLabels.push(histone);
                iHis++;
              }
	    });
	    $scope.histoneMap = histoneMap;
            deferred.resolve();
          }else{
            return deferred.reject(err);
          }
        
        });
        return deferred.promise;
      }
    };
    
    var genShouldQuery = function(rangeQueryArr) {
	var shouldQuery = [];
	rangeQueryArr.forEach(function(q) {
		shouldQuery.push({
			bool: {
				must: [
					{
						term: {
							chromosome: q.chr
						}
					},
					{
						bool: {
							should: [
								{
									range: {
										chromosome_start: {
											gte: q.start,
											lte: q.end
										}
									}
								},
								{
									range: {
										chromosome_end: {
											gte: q.start,
											lte: q.end
										}
									}
								},
								{
									bool: {
										must: [
											{
												range: {
													chromosome_start: {
														lte: q.end
													}
												}
											},
											{
												range: {
													chromosome_end: {
														gte: q.start
													}
												}
											}
										]
									}
								}
							]
						}
					}
				]
			}
		});
	});
	
	return shouldQuery;
    };


    var getWgbsData = function() {
      var deferred = $q.defer();
      var shouldQuery = genShouldQuery($scope.rangeQuery);
      es.search({
        size:10000000,
        index: 'primary',
        type: 'dlat.mr',
        search_type: 'count',
        body: {
          query: {
            filtered: {
              filter: {
                bool: {
                  should: shouldQuery
                }
              }
            }
          },
          aggs: {
            analyses: {
              terms: {
                field: 'analysis_id'
              },
              aggs: {
                stats_meth_level: {
                  extended_stats: {
                    field: 'meth_level'
                  }
                }
              }
            }
          }
        }
      },function(err,resp) {
        if(typeof(resp.aggregations) !== undefined){  
          resp.aggregations.analyses.buckets.forEach(function(d) {
            $scope.bisulfiteSeq.push(d);
          });
          deferred.resolve();
        }else{
          return deferred.reject(err); 
        }
      });
      
      return deferred.promise;
    };

    var getRnaSeqGData = function() {      
      var deferred = $q.defer();
      var shouldQuery = genShouldQuery($scope.rangeQuery);
      es.search({
        size:10000000,  
        index: 'primary',
        type: 'exp.g',
        search_type: 'count',
        body: {
          query: {
            filtered: {
              filter: {
                bool: {
                  should: shouldQuery
                }
              }
            }
          },
          aggs: {
            analyses: {
              terms: {
                field: 'analysis_id'
              },
              aggs: {
                stats_normalized_read_count: {
                  extended_stats: {
                    field: 'normalized_read_count'
                  }
                }
              }
            }
          }
        }
      },function(err,resp) {
        if(typeof(resp.aggregations) !== undefined){  
          resp.aggregations.analyses.buckets.forEach(function(d) {
            $scope.rnaSeqG.push(d);
          });
          deferred.resolve();
        }else{
          return deferred.reject(err); 
        }
      });
      
      return deferred.promise;
    };

    var getRnaSeqTData = function() {      
      var deferred = $q.defer();
      var shouldQuery = genShouldQuery($scope.rangeQuery);
      es.search({
        size:10000000,  
        index: 'primary',
        type: 'exp.t',
        search_type: 'count',
        body: {
          query: {
            filtered: {
              filter: {
                bool: {
                  should: shouldQuery
                }
              }
            }
          },
          aggs: {
            analyses: {
              terms: {
                field: 'analysis_id'
              },
              aggs: {
                stats_normalized_read_count: {
                  extended_stats: {
                    field: 'normalized_read_count'
                  }
                }
              }
            }
          }
        }
      },function(err,resp) {
        if(typeof(resp.aggregations) !== undefined){  
          resp.aggregations.analyses.buckets.forEach(function(d) {
            $scope.rnaSeqT.push(d);
          });
          deferred.resolve();
        }else{
          return deferred.reject(err); 
        }
      });
      
      return deferred.promise;
    };

    var getDnaseData = function() {      
      var deferred = $q.defer();
      var shouldQuery = genShouldQuery($scope.rangeQuery);
      es.search({
        size:10000000,  
        index: 'primary',
        type: 'rreg.p',
        search_type: 'count',
        body: {
          query: {
            filtered: {
              filter: {
                bool: {
                  should: shouldQuery
                }
              }
            }
          },
          aggs: {
            analyses:{
              terms:{
                field: 'analysis_id'
              },
              aggs:{
                peak_size: {
                  sum: {
                    lang: "expression",
                    script: "doc['chromosome_end'].value - doc['chromosome_start'].value + 1" 
                  }
                }
              }
            }
          }


        }
      },function(err,resp) {
        if(typeof(resp.aggregations) !== undefined){  
          resp.aggregations.analyses.buckets.forEach(function(d) {
            $scope.dnaseSeq.push(d);
          });
          deferred.resolve();
        }else{
          return deferred.reject(err); 
        }
      });
      
      return deferred.promise;
    };

    var chipSeqWindow = 500;
    
    var getChipSeqData = function() {      
      var deferred = $q.defer();
      var shouldQuery = genShouldQuery($scope.rangeQuery);
      es.search({
        size:10000000,  
        index: 'primary',
        type: 'pdna.p',
        search_type: 'count',
        body: {
          query: {
            filtered: {
              filter: {
                bool: {
                  should: shouldQuery
                }
              }
            }
          },
          aggs: {
            histones: {
              terms: {
                field: 'protein_stable_id'
              },
              aggs: {
                analyses:{
                  terms:{
                    field: 'analysis_id'
                  },
                  aggs:{
                    peak_size: {
                      sum: {
                        lang: "expression",
                        script: "doc['chromosome_end'].value - doc['chromosome_start'].value + 1" 
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },function(err,resp) {
        if(typeof(resp.aggregations) !== undefined){  
          resp.aggregations.histones.buckets.forEach(function(d) {
            $scope.chipSeq.push(d);
          });
          deferred.resolve();
        }else{
          return deferred.reject(err); 
        }
      });
      
      return deferred.promise;
    };

	var getSamples = function() {
		if($scope.samples.length===0) {
			var deferred = $q.defer();
			es.search({
				index: 'sample-tracking-data',
				type: 'sdata.sample',
				size: 100000,
			},function(err,resp){
				if(typeof(resp.hits.hits) !== undefined) {
					resp.hits.hits.forEach(function(d) {
						var s = {};
						s.analyzed_sample_type_other = d._source.analyzed_sample_type_other;
						s.sample_id = d._source.sample_id;
						s.ontology = d._source.purified_cell_type;
						s.markers = d._source.markers;
						s.experiments = [];
						$scope.labs.forEach(function(d){
							if(d.sample_id == s.sample_id){
								s.experiments.push(d);
							}
						});
						$scope.samplesOnt.push(s.ontology);
						$scope.samples.push(s);
					});
					
					var numSamples = $scope.samples.length;
					
					$scope.subtotals.data.push({
							key: 'Samples',
							y: numSamples
						}
					);
					
					deferred.resolve();
					//console.log($scope.samples);
				} else {
					return deferred.reject(err);
				}
			});
			return deferred.promise;
		}
	};

	var getDonors = function() {
		if($scope.donors.length===0) {
			var deferred = $q.defer();
			es.search({
				index: 'sample-tracking-data',
				type: 'sdata.donor',
				size: 100000,
			},function(err,resp){
				if(typeof(resp.hits.hits) !== undefined) {
					var subtotalsData = [];
					
					var numDonors = 0;
					var numPooledDonors = 0;
					var numCellularLines = 0;
					var numOther = 0;
					resp.hits.hits.forEach(function(d) {
						switch(d._source.donor_kind) {
							case 'd':
								numDonors++;
								break;
							case 'p':
								numPooledDonors++;
								break;
							case 'c':
								numCellularLines++;
								break;
							default:
								numOther++;
						}
						$scope.donors.push(d._source);
					});
					subtotalsData.push({
							key: 'Donors',
							y: numDonors
						},
						{
							key: 'Cellular Lines',
							y: numCellularLines
						},
						{
							key: 'Pooled Donors',
							y: numPooledDonors
						}
					);
					
					if(numOther>0) {
						subtotalsData.push({
								key: 'Other kind of donors',
								y: numOther
							}
						);
					}
					
					$scope.subtotals.data = subtotalsData;
					
					deferred.resolve();
					//console.log($scope.donors);
				} else {
					return deferred.reject(err);
				}
			});
			return deferred.promise;
		}
	};

    var getHistoneData = function(d,histone){
        
        var exp = 0;
        var value = 0.0;
        var expB = 0;
        var valueB = 0.0;
        d.analyses.forEach(function(analysis_id){
            var theValue = 0.0;
            var theExp = 0;
            $scope.chipSeq.forEach(function(a){
              if(a.key == histone){
                //console.log(a);
                a.analyses.buckets.forEach(function(c){
                  if(c.key == analysis_id){
                      theValue += parseFloat(c.peak_size.value);
                      theExp++;
                  }
                });
              }
            });
            if(analysis_id.indexOf('_broad_')!=-1) {
              expB += theExp;
              valueB += theValue;
            } else {
              exp += theExp;
              value += theValue;
            }
        });
        
        // This can be a bit incorrect for pathways...
        if(exp > 0 || expB > 0) {
          var region = 0;
          $scope.rangeQuery.forEach(function(r) {
	  	var end = r.end+chipSeqWindow;
	  	var start = r.start-chipSeqWindow;
	  	// Corner case
	  	if(start < 1) {
	  		start=1;
	  	}
	  	region += end - start + 1;
	  });
	  
          // console.log(region);
          if(exp > 0){
             //console.log(region);
            value = (value/region)*100.0;
          }
          if(expB > 0){
            valueB = (valueB/region)*100.0;
          }
        }
        return {notBroad:value, broad:valueB}; 
    };

    var populateBasicTree = function(o) {
	var numNodes = 1;
	// First, the children
	if(o.children) {
		o.children.forEach(function(child) {
			numNodes += populateBasicTree(child);
		});
	} else {
		o.children = [];
	}
	
	// And now, me!
	if(o.o_uri) {
		var aggregated_statistics = [];
		var childrens = [];
		$scope.experimentLabels.forEach(function() {
			aggregated_statistics.push(0);
			childrens.push(0);
		});
		$scope.samples.forEach(function(s) {
			if(s.ontology == o.o_uri) {
				o.analized = true;
				var statistics = [];
				$scope.experimentLabels.forEach(function() {
					statistics.push(0);
				});
				s.experiments.forEach(function(d){
					//console.log(d);
					var theStat = 0.0;
					if(d.experiment_type === 'DNA Methylation') {
						var methExp = 0;
						d.analyses.forEach(function(v) {
							$scope.bisulfiteSeq.forEach(function(a) {
								if(a.key == v){
									theStat += a.stats_meth_level.avg;
									methExp++;
								}
							});
						});
						if(methExp > 0.0){
							theStat = theStat/methExp;
							childrens[0]++;
						} else {
							theStat = NaN;
						}
						statistics[0] = theStat;
					} else if(d.experiment_type === 'Chromatin Accessibility') {
						var dnaseSeqExp = 0;
						d.analyses.forEach(function(v) {
							$scope.dnaseSeq.forEach(function(a) {
								if(a.key == v) {
									theStat += a.peak_size.value;
									dnaseSeqExp++;
								}
							});
						});
						if(dnaseSeqExp > 0) {
							// This can be a bit incorrect for pathways...
							var region = 0;
							$scope.rangeQuery.forEach(function(r) {
								region += r.end - r.start + 1;
							});
							theStat = theStat/region;
							childrens[1]++;
						} else {
							theStat = NaN;
						}
						statistics[1] = theStat;
					} else if(d.experiment_type === 'mRNA-seq') {
						// Expression at Gene and Transcript levels
						var rnaSeqExpG = 0;
						var rnaSeqExpT = 0;
						var theStatT = 0.0;
						
						d.analyses.forEach(function(v) {
							$scope.rnaSeqG.forEach(function(a) {
								if(a.key == v) {
									theStat += a.stats_normalized_read_count.avg;
									rnaSeqExpG++;
								}
							});
							$scope.rnaSeqT.forEach(function(a) {
								if(a.key == v) {
									theStatT += a.stats_normalized_read_count.avg;
									rnaSeqExpT++;
								}
							});
						});
						if(rnaSeqExpG > 0) {
							theStat = theStat/rnaSeqExpG;
							childrens[2]++;
						} else {
							theStat = NaN;
						}
						statistics[2] = theStat;
						
						if(rnaSeqExpT > 0) {
							theStatT = theStatT/rnaSeqExpT;
							childrens[3]++;
						} else {
							theStatT = NaN;
						}
						statistics[3] = theStatT;
					} else if(d.experiment_type.indexOf('Histone ')===0) {
						var normalizedHistone = d.features.CHIP_ANTIBODY.value.replace(/[.]/g,'_');
						
						if(normalizedHistone in $scope.histoneMap) {
							var expIdx = $scope.histoneMap[normalizedHistone];
							
							var histoneStats = getHistoneData(d,normalizedHistone);

							statistics[expIdx] = CSpeakSplit ? histoneStats.notBroad : (histoneStats.notBroad+histoneStats.broad);
							if(statistics[expIdx]>0) {
								childrens[expIdx]++;
							} else {
								statistics[expIdx] = NaN;
							}
								
							if(CSpeakSplit) {
								statistics[expIdx+1] = histoneStats.broad;
								if(statistics[expIdx+1]>0) {
									childrens[expIdx+1]++;
								} else {
									statistics[expIdx+1] = NaN;
								}
							}
						} else {
							console.log("Unmapped histone "+normalizedHistone);
						}
					}
				});
				
				// Translating to the right units
				if(!isNaN(statistics[0]) && statistics[0]!==-1) {
					statistics[0] *= 100.0;
				}
				
				if(!isNaN(statistics[1]) && statistics[1]!==-1) {
					statistics[1] *= 100.0;
				}
				
				statistics.forEach(function(stat,i) {
					if(!isNaN(stat) && stat!==-1) {
						aggregated_statistics[i] += stat;
					}
				});
				
				if($scope.display === 'detailed'){
					var newNode = {
						expData: statistics,
						name: s.sample_id,
						experimentsCount: s.experiments.length
					};
					
					o.children.push(newNode);
					numNodes++;
				}
			}
		});
                if(! o.expData) {
			//console.log(o[i]);
			var expData = [];
			aggregated_statistics.forEach(function(stat,i) {
				// Storing -1 for uninitialized cases
				expData.push((childrens[i] > 0)?(stat/childrens[i]):NaN);
			});
			o.expData = expData;
                }
	}
	return numNodes;
    };

    var initTree = function(){
	console.log("initializing tree");
	
	lastSearchMode = $scope.display;
	var clonedTreeData = angular.copy(fetchedTreeData);
	$scope.treedata = [];
	clonedTreeData.forEach(function(cloned) {
		var numNodes = populateBasicTree(cloned);
		$scope.treedata.push({root: cloned, numNodes: numNodes, depth:((lastSearchMode==='detailed')?$scope.depth+1:$scope.depth), experiments: $scope.experimentLabels});
	});
	$scope.searchButtonText = "Search";
    };

    var updateChromosomes = function(){
	var regions = '';
	$scope.chromosomes.forEach(function(d){
		d.c = "chr";
	});
	$scope.rangeQuery.forEach(function(part,i) {
		console.log('Updating chromosome data '+part.chr);
		$scope.chromosomes.forEach(function(d){
			if(d.n == part.chr) {
				d.c = "chr_active";
			}
		});
		
		if(i>0) {
			regions += ' ; ';
		}
		
		regions += "<a href='http://www.ensembl.org/Homo_sapiens/Location/View?r="+part.chr+":"+part.start+"-"+part.end+"' target='_blank'>chr"+part.chr+":"+part.start+"-"+part.end+"</a>";
	});
	$scope.found = "Displaying information from region"+(($scope.rangeQuery.length > 1)?'s':'')+": "+regions;
	if($scope.geneQuery !== null) {
		$scope.found += " ("+$scope.geneQueryType+" <a href='http://www.ensembl.org/Homo_sapiens/Gene/Summary?g="+$scope.ensemblGeneId+"&db=core' target='_blank'>"+$scope.geneQuery+" ["+$scope.ensemblGeneId+"]</a>)";
	} else if($scope.pathwayQuery !== null) {
		$scope.found += " (Pathway <a href='http://www.reactome.org/content/detail/"+$scope.pathwayQuery+"' target='_blank'>"+$scope.pathwayQuery+"</a>)";
	}
    };

    var getGeneRange = function(){
      var deferred = $q.defer();
      es.search({
        index: 'external',
        type: 'external.gencode',
        size: 1000,
        body: {
          query:{
            filtered:{
              query:{
                match: {
                  symbol:$scope.geneQuery 
                }
              },
              filter:{
                term:{
                  feature:"gene"
                }
              }
            }
          }
        }
      },function(err,resp){

        if(typeof(resp.hits.hits) !== undefined){
          $scope.rangeQuery.push({ chr: resp.hits.hits[0]._source.chromosome , start: resp.hits.hits[0]._source.chromosome_start, end: resp.hits.hits[0]._source.chromosome_end });
          $scope.ensemblGeneId = resp.hits.hits[0]._source.feature_cluster_id;
          $scope.geneQueryType = 'gene';
          //$scope.rangeQuery.chr = resp.hits.hits[0]._source.chromosome;
          //$scope.rangeQuery.start = resp.hits.hits[0]._source.chromosome_start;
          //$scope.rangeQuery.end = resp.hits.hits[0]._source.chromosome_end;
          //$scope.found = "Displaying information from region: chr"+$scope.rangeQuery[0].chr+":"+$scope.rangeQuery[0].start+"-"+$scope.rangeQuery[0].end+ " (Gene: "+$scope.geneQuery+")";
          updateChromosomes();
          deferred.resolve();

        }else{
          return deferred.reject(err);
        }

      });
      return deferred.promise;
    };
    
    var getPathwayRanges = function(){
	var deferred = $q.defer();
	es.search({
		index: 'external',
		type: 'external.reactome',
		size: 1000,
		body: {
			query:{
				filtered:{
					query:{
						match: {
							pathway_id:$scope.pathwayQuery 
						}
					}
				}
			}
		}
	},function(err,resp){
		if(typeof(resp.hits.hits) !== undefined){
			resp.hits.hits[0]._source.participants.forEach(function(part) {
				$scope.rangeQuery.push({ chr: part.chromosome , start: part.chromosome_start, end: part.chromosome_end });
			});
			updateChromosomes();
			deferred.resolve();
		} else {
			return deferred.reject(err);
		}
	});
	return deferred.promise;
    };
    
    var fetchCellTerms = function() {
	if(fetchedTreeData===undefined) {
		var deferred = $q.defer();
        
		// Let's calculate the unique terms
		var theUris=[];
		var theObj = {};
		$scope.samplesOnt.forEach(function(d) {
			if(!(d in theObj)) {
				theUris.push(d);
				theObj[d]=1;
			}
		});
		
		/*
		console.log("URIs");
		console.log(theUris);
		*/
		// Freeing the variable, as it is not needed, can cost time
		// theObj=undefined;
        
		es.search({
			index: 'meta-model',
			type: 'cvterm',
			size: 10000,
			body: {
				query: {
					filtered: {
						query: {
							match_all: {}
						},
						filter: {
							and: {
								filters: [{
									//term: {
									//	ont: 'cv:CellOntology'
									//}
									terms: {
										ont: ['cv:CellOntology','cv:EFO','cv:CellLineOntology']
									}
								},{
									terms: {
										alt_id: theUris
									}
								}]
							}
						}
					}
				},
				fields: ['term','ancestors']
			}
		}, function(err,resp) {
			if(resp.hits.total > 0) {
				// Let's gather all the distinct terms
				var theTerms = [];
				var theTermsHash = {};
				
				var theExtendedTerms = [];
				var theExtendedTermsHash = {};
				
				var maxDepth=0;
				resp.hits.hits.forEach(function(v) {
					var d = v.fields;
					var theTerm = d.term[0];
					if(!(theTerm in theTermsHash)) {
						theTerms.push(theTerm);
						theTermsHash[theTerm] = null;

						if(!(theTerm in theExtendedTermsHash)) {
							theExtendedTerms.push(theTerm);
							theExtendedTermsHash[theTerm]=null;
						}
						// There could be terms without ancestors
						var depth = 1;
						if(d.ancestors) {
							depth += d.ancestors.length;

							d.ancestors.forEach(function(term) {
								if(!(term in theExtendedTermsHash)) {
									theExtendedTerms.push(term);
									theExtendedTermsHash[term]=null;
								}
							});
						}
						if(depth > maxDepth) {
							maxDepth = depth;
						}
					}
				});
				$scope.depth = maxDepth;
				
				/*
				console.log("Terms");
				console.log(theTerms);
				*/
				
				// Now, send the query to fetch all of them
				es.search({
					index: 'meta-model',
					type: 'cvterm',
					size: 10000,
					body: {
						query: {
							filtered: {
								query: {
									match_all: {}
								},
								filter: {
									terms: {
										term: theExtendedTerms
									}
								}
							}
						},
						fields: ['term','term_uri','name','parents']
					}
				}, function(err, resp) {
					if(resp.hits.total > 0) {
						// And rebuild the tree!
						var fetchedNodes = {};
						var treeNodes = {};
						
						// Roots are the nodes with no parent
						var roots = [];
						
						// First pass, the nodes
						resp.hits.hits.forEach(function(v) {
							var n = v.fields;
							treeNodes[n.term[0]] = {
								name: n.name[0],
								o: n.term[0],
								o_uri: n.term_uri[0]
							};
							
							fetchedNodes[n.term[0]] = n;
						});
						/*
						console.log("Extended terms");
						console.log(theExtendedTerms);
						console.log("Fetched Nodes");
						console.log(fetchedNodes);
						console.log("Tree Nodes");
						console.log(treeNodes);
						*/
						
						// Second pass, the parent-child relationships
						for(var theTerm in fetchedNodes) {
							var n = fetchedNodes[theTerm];
							var tn = treeNodes[theTerm];
							if(! tn.visited) {
								if(n.parents) {
									var added = 0;
									n.parents.forEach(function(p) {
										// Skipping multi-parenting cases, to artificially prune the DAG into a tree
										if(p in treeNodes) {
											var ptn = treeNodes[p];
											if(added===0) {
												if(! ptn.children) {
													ptn.children = [];
												}
												
												ptn.children.push(tn);
											} else {
												if(! ptn.links) {
													ptn.links = [];
												}
												
												ptn.links.push(tn);
											}
											added++;
										}
									});
								} else {
									// This is a root
									roots.push(tn);
								}
								tn.visited = true;
							}
						}
						
						// Due the artificial translation into a tree, there are many dead branches
						// Now, let's see the involved nodes
						var nowNodes = [].concat(roots);
						var leafDeadNodes = [];
						while(nowNodes.length > 0) {
						 	var nextNodes = [];
						 	nowNodes.forEach(function(t) {
						 		if(t.children && t.children.length > 0) {
						 			nextNodes = nextNodes.concat(t.children);
						 		} else if(!(t.o in theTermsHash)) {
									leafDeadNodes.push(t);
								}
						 	});
						 	nowNodes = nextNodes;
						}
						
						// And let's prune the tree
						var rounds = 0;
						while(leafDeadNodes.length > 0) {
							// Debugging
							/*
							var lonames = [];
							var loterms = [];
							leafDeadNodes.forEach(function(lo) {
								lonames.push(lo.name);
								loterms.push(lo.o);
							});
							console.log("Round "+rounds);
							console.log(lonames);
							console.log(loterms);
							*/
							rounds++;
                                                        
                                                        // Now, remove the dead nodes
							var nextDeadNodes = [];
							leafDeadNodes.forEach(function(lo) {
								var l = fetchedNodes[lo.o];
								l.parents.some(function(po) {
									if(po in treeNodes) {
										var p=treeNodes[po];
										if(p.children && p.children.length>0) {
											var pl=-1;
											p.children.some(function(child,iCh) {
												if(child.o==lo.o) {
													pl=iCh;
													return true;
												}
												return false;
											});
											if(pl!==-1) {
												p.children.splice(pl,1);
												if(!(p.o in theTermsHash) && p.children.length===0) {
													delete(p.children);
													nextDeadNodes.push(p);
												}
											/*
											} else {
												console.log("Raro "+lo.o);
												console.log(p);
											*/
											}
										}
										return true;
									}
									return false;
								});
							});
							leafDeadNodes = nextDeadNodes;
						}
						
						// Sort by root uri
						fetchedTreeData = roots.sort(function(a,b) { return a.o_uri.localeCompare(b.o_uri); });
						deferred.resolve();
					} else {
						return deferred.reject(err);
					}
				});
			} else {
				return deferred.reject(err);
			}
		});
		return deferred.promise;
	}
    };

    var preprocessQuery = function(){

      console.log('Running preprocessQuery');
      var deferred = $q.defer();
      var promise = deferred.promise;
      
	if($scope.suggestedQuery) {
		if($scope.suggestedQuery.feature != REACT_FEATURE) {
			$scope.rangeQuery.push({ chr: $scope.suggestedQuery.chromosome , start: $scope.suggestedQuery.chromosome_start, end: $scope.suggestedQuery.chromosome_end });
			$scope.ensemblGeneId = $scope.suggestedQuery.feature_cluster_id;
			$scope.geneQuery = $scope.suggestedQuery.term;
			$scope.geneQueryType = $scope.suggestedQuery.feature;
			if($scope.suggestedQuery.feature!=='gene') {
				$scope.geneQueryType += ' from gene,';
			}
			//$scope.rangeQuery.chr = resp.hits.hits[0]._source.chromosome;
			//$scope.rangeQuery.start = resp.hits.hits[0]._source.chromosome_start;
			//$scope.rangeQuery.end = resp.hits.hits[0]._source.chromosome_end;
			//$scope.found = "Displaying information from region: chr"+$scope.rangeQuery[0].chr+":"+$scope.rangeQuery[0].start+"-"+$scope.rangeQuery[0].end+ " (Gene: "+$scope.geneQuery+")";
		} else {
			$scope.pathwayQuery = $scope.suggestedQuery.term;
			$scope.suggestedQuery.participants.forEach(function(part) {
				$scope.rangeQuery.push({ chr: part.chromosome , start: part.chromosome_start, end: part.chromosome_end });
			});
		}
		updateChromosomes();
      } else {
      
        var q = $scope.query.trim();
        var m = q.match('^chr(.*):(.*)-(.*)$');
        var react = q.indexOf(REACT_PREFIX) === 0;
        
        //range query
        if(m){
          if(m[1] === 'M') {
            // Normalizing mitochondrial chromosome name
            m[1] = 'MT';
          }
          $scope.rangeQuery.push({chr: m[1], start: m[2], end: m[3]});
          // $scope.rangeQuery.chr   = m[1];
          // $scope.rangeQuery.start = m[2];
          // $scope.rangeQuery.end   = m[3];
          // $scope.found = "Displaying information from region: chr"+$scope.rangeQuery[0].chr+":"+$scope.rangeQuery[0].start+"-"+$scope.rangeQuery[0].end;
          updateChromosomes();
        } else if(react) {
          $scope.pathwayQuery = q;
          promise = promise.then(getPathwayRanges);
        } else {
          $scope.geneQuery = q;
          promise = promise.then(getGeneRange);
        } 
      }
      deferred.resolve();
      return promise;
    };

    $scope.resultsSearch = [];
    
    $scope.search = function(theSuggest){
        $scope.found = "";
        $scope.suggestedQuery = theSuggest;
        $scope.resultsSearch = [];
        //$scope.samplesOnt = [];
        //$scope.samples = [];
        //$scope.labs = [];
        //$scope.analyses = [];
        $scope.bisulfiteSeq = [];
        $scope.rnaSeqG = [];
        $scope.rnaSeqT = [];
        $scope.chipSeq = [];
        $scope.dnaseSeq = [];
        $scope.treedata = null;
        $scope.rangeQuery = [];
        $scope.geneQuery = null;
        $scope.ensemblGeneId = null;
        $scope.pathwayQuery = null;

        $scope.searchButtonText = "Searching...";

        var deferred = $q.defer();
        var promise = deferred.promise;
        promise = promise.then(preprocessQuery)
                         .then(getAnalyses)
                         .then(getLabs)
                         .then(getSamples)
                         .then(fetchCellTerms)
                         .then(getWgbsData)
                         .then(getRnaSeqGData)
                         .then(getRnaSeqTData)
                         .then(getChipSeqData)
                         .then(getDnaseData)
                         //.then(preprocessQuery)
                         .then(initTree);
        deferred.resolve();
    };
    
    
	var my_feature_ranking = {
		gene: 1,
		transcript: 2,
		exon: 3,
		CDS: 4,
		UTR: 5,
		start_codon: 6,
		stop_codon: 7,
		Selenocysteine: 8
	};
	
    $scope.suggest = function() {
	$scope.resultsSearch = [];
	$scope.suggestedQuery = null;
	
	if($scope.query.length >= 3) {
		if($scope.query.indexOf(REACT_PREFIX) === 0) {
			es.search({
				index: 'external',
				type: 'external.reactome',
				size: 50,
				body: {
					query:{
						filtered: {
							query: {
								match_all: {}
							},
							filter: {
								prefix: {
									pathway_id: $scope.query
								}
							}
						}
					},
				}
			},function(err,resp) {
				var resultsSearch = [];
				
				// Only process at most 50 suggestions
				resp.hits.hits.forEach(function(sug) {
					var pathway_id = sug._source.pathway_id;
					resultsSearch.push({term: pathway_id, fullTerm: pathway_id, feature: REACT_FEATURE, participants: sug._source.participants});
				});
				
				$scope.resultsSearch = resultsSearch;
			});
		} else {
			var query = $scope.query.toLowerCase();
			es.search({
				index: 'external',
				type: 'external.gencode',
				size: 5000,
				body: {
					query:{
						filtered: {
							query: {
								match_all: {}
							},
							filter: {
								prefix: {
									symbol: query
								}
							}
						}
					},
					fields: ['symbol','chromosome','chromosome_start','chromosome_end','feature','feature_cluster_id'],
				}
			},function(err,resp){
				var resultsSearch = [];
				
				resp.hits.hits.forEach(function(sug,i) {
					var theTerm = undefined;
					var theSecondTerm = undefined;
					var isFirst = 0;
					sug.fields.symbol.forEach(function(term) {
						var termpos = term.toLowerCase().indexOf(query);
						if(termpos===0) {
							if(theTerm===undefined || term.length < theTerm.length) {
								theTerm = term;
							}
						} else if(termpos!==-1) {
							if(theSecondTerm===undefined || term.length < theSecondTerm.length) {
								theSecondTerm = term;
							}
						}
					});
					
					// A backup default
					if(theTerm===undefined) {
						if(theSecondTerm !== undefined) {
							isFirst = 1;
							theTerm = theSecondTerm;
						} else {
							isFirst = 2;
							theTerm = sug.fields.symbol[0];
						}
					}
					var feature = sug.fields.feature[0];
					var featureScore = (feature in my_feature_ranking) ? my_feature_ranking[feature] : 255;
					resultsSearch.push({term:theTerm, pos:i, isFirst: isFirst, fullTerm: theTerm+' ('+sug.fields.symbol.join(", ")+')', id:sug._id,chromosome:sug.fields.chromosome[0],chromosome_start:sug.fields.chromosome_start[0],chromosome_end:sug.fields.chromosome_end[0],feature:feature,featureScore:featureScore, feature_cluster_id:sug.fields.feature_cluster_id[0]});
				});
				
				resultsSearch.sort(function(a,b) {
					if(a.featureScore != b.featureScore) {
						return a.featureScore - b.featureScore;
					} else if(a.isFirst != b.isFirst) {
						return a.isFirst - b.isFirst;
					} else if(a.term.length != b.term.length) {
						return a.term.length - b.term.length;
					} else {
						return a.term.localeCompare(b.term);
					}
				});
				
				var curFeat = '';
				var numFeat = 0;
				resultsSearch.forEach(function(r) {
					if(r.feature != curFeat) {
						curFeat = r.feature;
						numFeat = 0;
					}
					if(numFeat<4) {
						$scope.resultsSearch.push(r);
						numFeat++;
					}
				});
			});
		}
	}
    };
    
	$scope.enterSearch = function(keyEvent) {
		if(keyEvent.which === 13 && $scope.query.length > 0) {
			//if($scope.resultsSearch.length > 0) {
			//	$scope.search($scope.resultsSearch[0]);
			//} else {
				$scope.search();
			//}
		}
	};

	var init = function($q) {
		var deferred = $q.defer();
		var promise = deferred.promise;
		promise = promise.then(getDonors)
				.then(getAnalyses)
				.then(getLabs)
				.then(getSamples);
		deferred.resolve();
	};
	
	init($q);
}]);
