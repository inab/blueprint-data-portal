'use strict';

/*jshint camelcase: false , quotmark: false */

/**
 * @ngdoc function
 * @name blueprintApp.controller:MainCtrl
 * @description
 * # MainCtrl
 * Controller of the blueprintApp
 */
angular.module('blueprintApp')
  .controller('MainCtrl', ['$scope','$location','$q','es','portalConfig','d3',function($scope,$location,$q, es, portalConfig, d3) {
	
	var DATA_CHART_TYPE = 'lineChart';
	var DATA_CHART_HEIGHT = 400;
	var SEARCHING_LABEL = "Searching...";
	var SEARCH_LABEL = "Search";
	
	var METHYL_GRAPH = 'methyl';
	var EXP_GRAPH = 'exp';
	var CSEQ_GRAPH = 'cseq';
	var DNASE_GRAPH = 'dnase';
	var GRAPHS = [
		{
			name: METHYL_GRAPH,
			noData: 'methylated regions',
			title: 'Methylated regions',
			yAxisLabel: 'Methylation level',
		},
		{
			name: EXP_GRAPH,
			noData: 'expression data',
			title: 'Expression (gene and transcript)',
			yAxisLabel: 'FPKM',
		},
		{
			name: CSEQ_GRAPH,
			noData: 'histone peaks',
			title: 'Histone Peaks (broad and narrow)',
			yAxisLabel: 'Log10(q-value)',
		},
		{
			name: DNASE_GRAPH,
			noData: 'regulatory regions',
			title: 'Regulatory regions (DNASE)',
			yAxisLabel: 'z-score',
		},
	];
	var DLAT_CONCEPT = 'dlat.mr';
	var PDNA_CONCEPT = 'pdna.p';
	var EXPG_CONCEPT = 'exp.g';
	var EXPT_CONCEPT = 'exp.t';
	var RREG_CONCEPT = 'rreg.p';
	
	var ConceptToChart = {};
	ConceptToChart[DLAT_CONCEPT] = METHYL_GRAPH;
	ConceptToChart[PDNA_CONCEPT] = CSEQ_GRAPH;
	ConceptToChart[EXPG_CONCEPT] = EXP_GRAPH;
	ConceptToChart[EXPT_CONCEPT] = EXP_GRAPH;
	ConceptToChart[RREG_CONCEPT] = DNASE_GRAPH;
	
	var CHR_SEGMENT_LIMIT = 2500000;	// A bit larger than largest gene
	
    var pageNum = 1;
    var perPage = 50;
    var experimentLabels = ['Bisulfite-Seq','DNase-Seq','Gene Exp (RNA-Seq)','Transcript Exp (RNA-Seq)'];

    var fetchedTreeData;
    var lastSearchMode;

    $scope.info = '<p><a href="http://www.blueprint-epigenome.eu/"><img src="http://dcc.blueprint-epigenome.eu/img/blueprint.png" style="float:left;height:50px;margin-right:20px;"></a>BLUEPRINT is a high impact FP7 project aiming to produce a blueprint of haemopoetic epigenomes. Our goal is to apply highly sophisticated functional genomics analysis on a clearly defined set of primarily human samples from healthy and diseased individuals, and to provide at least 100 <a href="http://ihec-epigenomes.org/research/reference-epigenome-standards/" title="IHEC reference epigenome standards">reference epigenomes</a> to the scientific community. This resource-generating activity will be complemented by research into blood-based diseases, including common leukaemias and autoimmune disease (Type 1 Diabetes), by discovery and validation of epigenetic markers for diagnostic use and by epigenetic target identification.This may eventually lead to the development of novel and more individualised medical treatments. This website will provide links to the data &amp; primary analysis generated by the project.</p>'; 

    $scope.dataRelease = '[Dev without config]';
    $scope.dataDesc = '[Dev without config]';
    if(portalConfig.dataRelease) {
        $scope.dataRelease = portalConfig.dataRelease;
    }
    if(portalConfig.dataDesc) {
        $scope.dataDesc = portalConfig.dataDesc;
    }

    $scope.queryInProgress = false;
    $scope.suggestInProgress = false;
    $scope.searchButtonText = SEARCH_LABEL;
    $scope.found = "";
    $scope.samplesOnt = [];
    $scope.samples = [];
    $scope.specimens = [];
    $scope.donors = [];
    $scope.labs = [];
    $scope.analyses = [];
    $scope.experimentLabels = [];
    $scope.depth=null;
    $scope.histoneMap = {};
    //$scope.bisulfiteSeq = [];
    //$scope.rnaSeqG = [];
    //$scope.rnaSeqT = [];
    //$scope.chipSeq = [];
    //$scope.dnaseSeq = [];
    //$scope.treedata = null;
    $scope.rangeQuery = [];
    $scope.ensemblGeneId = null;
    $scope.currentQuery = null;
    $scope.currentQueryType = null;
    
	$scope.graphData = [];
    
    
    
    
    
    $scope.display = 'compact';
    $scope.chromosomes = [{n:1,c:"chr",f:"images/GRCh38_chromosome_1.svg"},
                    {n:2,c:"chr",f:"images/GRCh38_chromosome_2.svg"},
                    {n:3,c:"chr",f:"images/GRCh38_chromosome_3.svg"},
                    {n:4,c:"chr",f:"images/GRCh38_chromosome_4.svg"},
                    {n:5,c:"chr",f:"images/GRCh38_chromosome_5.svg"},
                    {n:6,c:"chr",f:"images/GRCh38_chromosome_6.svg"},
                    {n:7,c:"chr",f:"images/GRCh38_chromosome_7.svg"},
                    {n:8,c:"chr",f:"images/GRCh38_chromosome_8.svg"},
                    {n:9,c:"chr",f:"images/GRCh38_chromosome_9.svg"},
                    {n:10,c:"chr",f:"images/GRCh38_chromosome_10.svg"},
                    {n:11,c:"chr",f:"images/GRCh38_chromosome_11.svg"},
                    {n:12,c:"chr",f:"images/GRCh38_chromosome_12.svg"},
                    {n:13,c:"chr",f:"images/GRCh38_chromosome_13.svg"},
                    {n:14,c:"chr",f:"images/GRCh38_chromosome_14.svg"},
                    {n:15,c:"chr",f:"images/GRCh38_chromosome_15.svg"},
                    {n:16,c:"chr",f:"images/GRCh38_chromosome_16.svg"},
                    {n:17,c:"chr",f:"images/GRCh38_chromosome_17.svg"},
                    {n:18,c:"chr",f:"images/GRCh38_chromosome_18.svg"},
                    {n:19,c:"chr",f:"images/GRCh38_chromosome_19.svg"},
                    {n:20,c:"chr",f:"images/GRCh38_chromosome_20.svg"},
                    {n:21,c:"chr",f:"images/GRCh38_chromosome_21.svg"},
                    {n:22,c:"chr",f:"images/GRCh38_chromosome_22.svg"},
                    {n:"X",c:"chr",f:"images/GRCh38_chromosome_X.svg"},
                    {n:"Y",c:"chr",f:"images/GRCh38_chromosome_Y.svg"},
                    {n:"MT",c:"chr",f:"images/GRCh38_chromosome_MT.svg"}
                  ];

	$scope.unknownChromosome = { n: "(unknown)", f: "images/chr.svg" };

    $scope.results = null;
    
	var getXG = function(d) {
		return d[0];
	};
	
	var getYG = function(d) {
		return d[1];
	};
	
	var getKey = function(d) {
		return d.key;
	};
	
	var getY = function(d) {
		return d.y;
	};
	
	$scope.subtotals = {
		options: {
			chart: {
				type: 'pieChart',
				height: 475,
				width: 400,
				margin: {
					top: 0,
					right: 0,
					bottom: 0,
					left: 0
				},
				x: getKey,
				y: getY,
				//showLegend: false,
				showLabels: true,
				donut:true,
				title: "Donors & Samples",
				labelsOutside: true,
				labelSunbeamLayout: true,
				labelType: "value",
				transitionDuration: 500,
				labelThreshold: 0.01,
				valueFormat: d3.format('d')
			},
		},
		data: [
			{
				key: "Loading",
				y: 1
			},
		],
	};
	
	//Format function for the tooltip values column
	var valueFormatter = function(d,i) {
		return d;
	};
	
	//Format function for the tooltip header value.
	var headerFormatter = function(d) {
		return d;
	};
	
	var keyFormatter = function(d, i) {
		return d;
	};
	
	var analysisPieTooltipGenerator = function (d) {
		if (d === null) {
			return '';
		}
		
		var headerEnabled;
		
		var table = d3.select(document.createElement("table"));
		if(headerEnabled) {
			var theadEnter = table.selectAll("thead")
				.data([d])
				.enter().append("thead");
			
			theadEnter.append("tr")
				.append("td")
				.attr("colspan", 3)
				.append("strong")
				.classed("x-value", true)
				.html(headerFormatter(d.value));
		}
		
		var tbodyEnter = table.selectAll("tbody")
			.data([d])
			.enter().append("tbody");
		
		var trowEnter = tbodyEnter.selectAll("tr")
			.data(function(p) { return p.series; })
			.enter()
			.append("tr")
			.classed("highlight", function(p) { return p.highlight; });
		
		trowEnter.append("td")
			.classed("legend-color-guide",true)
			.append("div")
			.style("background-color", function(p) { return p.color; });
		
		trowEnter.append("td")
			.classed("key",true)
			.html(function(p, i) { return keyFormatter(d.data.desc, i); });
		
		trowEnter.append("td")
			.classed("value",true)
			.html(function(p, i) { return valueFormatter(p.value, i); });
		
		trowEnter.selectAll("td").each(function(p) {
			if (p.highlight) {
				var opacityScale = d3.scale.linear().domain([0,1]).range(["#fff",p.color]);
				var opacity = 0.6;
				d3.select(this)
				.style("border-bottom-color", opacityScale(opacity))
				.style("border-top-color", opacityScale(opacity))
				;
			}
		});
		
		var html = table.node().outerHTML;
		if(d.footer !== undefined) {
			html += "<div class='footer'>" + d.footer + "</div>";
		}
		return html;
	};
	
	$scope.analysisSubtotals = {
		options: {
			chart: {
				type: 'pieChart',
				height: 475,
				width: 400,
				margin: {
					top: 0,
					right: 0,
					bottom: 0,
					left: 0
				},
				x: getKey,
				y: getY,
				showLabels: true,
				donut:true,
				title: "Analysis",
				labelsOutside: true,
				labelSunbeamLayout: true,
				labelType: "value",
				tooltip: {
					contentGenerator: analysisPieTooltipGenerator,
				},
				legend: {
					margin: {
						left: 3,
					},
					//key: function(d) { console.log(d) },
				},
				transitionDuration: 500,
				labelThreshold: 0.01,
				valueFormat: d3.format('d')
			},
			//caption: {
			//	enable: true,
			//	text: 'Analysis',
			//	css: {
			//		textAlign: 'center'
			//	}
			//}
		},
		data: [
			{
				key: "Loading",
				y: 1
			},
		]
	};
    
    // If we set this to 1, we separate broad from narrow peaks
    var CSpeakSplit;

	var getAnalyses = function(localScope) {
		if(localScope.analyses!==undefined && localScope.analyses.length !== 0) {
			return localScope;
		}
		
		localScope.analyses = [];
		return es.search({
			size: 10000000,
			index: 'metadata',
			body: {
				query: {
					filtered: {
						filter: {
							bool: {
								must: [
									{exists : { field : 'experiment_id' }},
									{exists : { field : 'analysis_id' }}
								]  
							}
						}
					}
				}
		
			}
		}).then(function(resp){
			if(typeof(resp.hits.hits) !== undefined) {
				// Now, the analysis subtotals
				var numDlatHyper = 0;
				var numDlatHypo = 0;
				var numDlatOther = 0;
				
				var numCSbroad = 0;
				var numCSnarrow = 0;
				
				var numExpG = 0;
				var numExpT = 0;
				
				var numRReg = 0;
				var numAnOther = 0;
				
				resp.hits.hits.forEach(function(d) {
					d._source._type = d._type;
					switch(d._type) {
						case 'dlat.m':
							switch(d._source.mr_type) {
								case 'hyper':
									numDlatHyper++;
									break;
								case 'hypo':
									numDlatHypo++;
									break;
								default:
									numDlatOther++;
									break;
							}
							
							break;
						case 'pdna.m':
							if(d._source.analysis_id.indexOf('_broad_')!==-1) {
								numCSbroad++;
							} else {
								numCSnarrow++;
							}
							break;
						case 'exp.m':
							numExpG++;
							numExpT++;
							break;
						case 'rreg.m':
							numRReg++;
							break;
						default:
							numAnOther++;
					}
					localScope.analyses.push(d._source);
				});
				
				var analysisSubtotals = [
					{
						key: 'Hyper-m regions',
						desc: 'Hyper-methylated regions',
						y: numDlatHyper
					},
					{
						key: 'Hypo-m regions',
						desc: 'Hypo-methylated regions',
						y: numDlatHypo
					},
				];
				
				if(numDlatOther > 0) {
					analysisSubtotals.push({
						key: 'Other m regions',
						desc: 'Other methylated regions',
						y: numDlatOther
					});
				}
				
				analysisSubtotals.push(
					{
						key: 'CS broad',
						desc: 'ChIP-Seq (broad peaks)',
						y: numCSbroad
					},
					{
						key: 'CS narrow',
						desc: 'ChIP-Seq (narrow peaks)',
						y: numCSnarrow
					},
					{
						key: 'Gene exp',
						desc: 'Gene expression',
						y: numExpG
					},
					{
						key: 'Transcript exp',
						desc: 'Transcript expression',
						y: numExpT
					},
					{
						key: 'Chrom Acc',
						desc: 'Chromatin accessibility',
						y: numRReg
					}
				);
				
				if(numAnOther > 0) {
					analysisSubtotals.push({
						key: 'Other',
						desc: 'Other',
						y: numAnOther
					});
				}
				
				localScope.analysisSubtotals.data = analysisSubtotals;
			//} else {
			//	return deferred.reject(err);
			}
			
			return localScope;
		});
	};

	var getLabs = function(localScope) {
		// As it should get an array of local scopes, which should be the same, let's use the first one
		if(Array.isArray(localScope)) {
			localScope = localScope[0];
		}
		
		if(localScope.labs!==undefined && localScope.labs.length!==0) {
			return localScope;
		}
		
		localScope.labs = [];
		
		var deferred = $q.defer();
		es.search({
			size:100000,
			index: 'sample-tracking-data',
			body:{
				query: {
					filtered: {
						filter: {
							bool: {
								must: [
									{exists : { field : 'experiment_id' }},
									// {exists : { field : 'analized_sample_id' }}
									{exists : { field : 'experiment_type' }}
								]	
							}
						}
					}
				}
		
			}
		},function(err,resp){
			if(typeof(resp.hits.hits) !== 'undefined'){
				var histones = [];
				var histoneMap = {};
				resp.hits.hits.forEach(function(d) {
					var	l = {};
					l.type	= d._type;
					l.sample_id = d._source.analyzed_sample_id;
					l.experiment_id = d._source.experiment_id;
					l.experiment_type = d._source.experiment_type;
					l.features = d._source.features;
					if(l.experiment_type.indexOf('Histone ')===0) {
						var histone = l.features.CHIP_ANTIBODY.value;
						var normalizedHistone = histone.replace(/[.]/g,'_');
						
						// Registering new histones
						if(!(normalizedHistone in histoneMap)) {
							histoneMap[normalizedHistone] = null;
							histones.push(histone);
						}
					}
		
					if(typeof(l.analyses) === 'undefined'){
						l.analyses = [];
						localScope.analyses.forEach(function(d){
							if (d.experiment_id == l.experiment_id){
									l.analyses.push(d.analysis_id);
							}
						});
					}
					localScope.labs.push(l);
				});
				
				// Now, map the histones and generated the labels
				localScope.experimentLabels = angular.copy(experimentLabels);
				var iHis = localScope.experimentLabels.length;
				histones.sort().forEach(function(histone) {
					var normalizedHistone = histone.replace(/[.]/g,'_');
					histoneMap[normalizedHistone] = iHis;
					
					if(CSpeakSplit) {
						// It uses two slots
						localScope.experimentLabels.push(histone+' (peaks)');
						localScope.experimentLabels.push(histone+' (broad peaks)');
						iHis+=2;
					} else {
						localScope.experimentLabels.push(histone);
						iHis++;
					}
				});
				localScope.histoneMap = histoneMap;
				
				deferred.resolve(localScope);
			} else {
				return deferred.reject(err);
			}
		
		});
		
		return deferred.promise;
	};
    
	var genShouldQuery = function(rangeQueryArr) {
		// We transform it into an array, in case it is not yet
		if(!Array.isArray(rangeQueryArr)) {
			rangeQueryArr = [ rangeQueryArr ];
		}
		var shouldQuery = rangeQueryArr.map(function(q) {
			return {
				bool: {
					must: [
						{
							term: {
								chromosome: q.chr
							}
						},
						{
							bool: {
								should: [
									{
										range: {
											chromosome_start: {
												gte: q.start,
												lte: q.end
											}
										}
									},
									{
										range: {
											chromosome_end: {
												gte: q.start,
												lte: q.end
											}
										}
									},
									{
										bool: {
											must: [
												{
													range: {
														chromosome_start: {
															lte: q.end
														}
													}
												},
												{
													range: {
														chromosome_end: {
															gte: q.start
														}
													}
												}
											]
										}
									}
								]
							}
						}
					]
				}
			};
		});
		
		return shouldQuery;
	};
	
	var launch = function() {
		var theArgs = arguments;
		return function(localScope) {
			if(Array.isArray(localScope)) {
				localScope = localScope[0];
			}
			
			var queries = [];
			
			for(var t=0;t<theArgs.length;t++) {
				var theFunc = theArgs[t];
				localScope.graphData.forEach(function(rangeData) {
					//try {
						queries.push(theFunc(localScope,rangeData));
					//} catch(e) {
					//	console.log("Mira");
					//	console.log(e);
					//}
				});
			}
			
			if(queries.length > 0) {
				return queries.length===1 ? queries[0] : $q.all(queries);
			}
		};
	};
	
	var getWgbsStatsData = function(localScope,rangeData) {
		var deferred = $q.defer();
		var shouldQuery = genShouldQuery(rangeData.range);
		es.search({
			size:10000000,
			index: 'primary',
			type: DLAT_CONCEPT,
			search_type: 'count',
			body: {
				query: {
					filtered: {
						filter: {
							bool: {
								should: shouldQuery
							}
						}
					}
				},
				aggs: {
					analyses: {
						terms: {
							field: 'analysis_id'
						},
						aggs: {
							stats_meth_level: {
								extended_stats: {
									field: 'meth_level'
								}
							}
						}
					}
				}
			}
		},function(err,resp) {
			if(typeof(resp.aggregations) !== undefined){  
				resp.aggregations.analyses.buckets.forEach(function(d) {
					rangeData.stats.bisulfiteSeq.push(d);
				});
				deferred.resolve(localScope);
			} else {
				return deferred.reject(err); 
			}
		});
		
		return deferred.promise;
	};
	
	var getRnaSeqGStatsData = function(localScope,rangeData) {
		var deferred = $q.defer();
		var shouldQuery = genShouldQuery(rangeData.range);
		es.search({
			size:10000000,	
			index: 'primary',
			type: EXPG_CONCEPT,
			search_type: 'count',
			body: {
				query: {
					filtered: {
						filter: {
							bool: {
								should: shouldQuery
							}
						}
					}
				},
				aggs: {
					analyses: {
						terms: {
							field: 'analysis_id'
						},
						aggs: {
							stats_normalized_read_count: {
								extended_stats: {
									field: 'expected_count'
								}
							}
						}
					}
				}
			}
		},function(err,resp) {
			if(typeof(resp.aggregations) !== undefined){	
				resp.aggregations.analyses.buckets.forEach(function(d) {
					rangeData.stats.rnaSeqG.push(d);
				});
				deferred.resolve(localScope);
			} else {
				return deferred.reject(err); 
			}
		});
		
		return deferred.promise;
	};

	var getRnaSeqTStatsData = function(localScope,rangeData) {
		var deferred = $q.defer();
		var shouldQuery = genShouldQuery(rangeData.range);
		es.search({
			size:10000000,	
			index: 'primary',
			type: EXPT_CONCEPT,
			search_type: 'count',
			body: {
				query: {
					filtered: {
						filter: {
							bool: {
								should: shouldQuery
							}
						}
					}
				},
				aggs: {
					analyses: {
						terms: {
							field: 'analysis_id'
						},
						aggs: {
							stats_normalized_read_count: {
								extended_stats: {
									field: 'expected_count'
								}
							}
						}
					}
				}
			}
		},function(err,resp) {
			if(typeof(resp.aggregations) !== undefined){	
				resp.aggregations.analyses.buckets.forEach(function(d) {
					rangeData.stats.rnaSeqT.push(d);
				});
				deferred.resolve(localScope);
			} else {
				return deferred.reject(err); 
			}
		});
		
		return deferred.promise;
	};

	var getDnaseStatsData = function(localScope,rangeData) {
		var deferred = $q.defer();
		var shouldQuery = genShouldQuery(rangeData.range);
		es.search({
			size:10000000,	
			index: 'primary',
			type: RREG_CONCEPT,
			search_type: 'count',
			body: {
				query: {
					filtered: {
						filter: {
							bool: {
								should: shouldQuery
							}
						}
					}
				},
				aggs: {
					analyses:{
						terms:{
							field: 'analysis_id'
						},
						aggs:{
							peak_size: {
								sum: {
									lang: "expression",
									script: "doc['chromosome_end'].value - doc['chromosome_start'].value + 1" 
								}
							}
						}
					}
				}


			}
		},function(err,resp) {
			if(typeof(resp.aggregations) !== undefined){	
				resp.aggregations.analyses.buckets.forEach(function(d) {
					rangeData.stats.dnaseSeq.push(d);
				});
				deferred.resolve(localScope);
			}else{
				return deferred.reject(err); 
			}
		});
		
		return deferred.promise;
	};
	
	var chipSeqWindow = 500;
	
	var getChipSeqStatsData = function(localScope,rangeData) {			
		var deferred = $q.defer();
		var shouldQuery = genShouldQuery(rangeData.range);
		es.search({
			size:10000000,	
			index: 'primary',
			type: PDNA_CONCEPT,
			search_type: 'count',
			body: {
				query: {
					filtered: {
						filter: {
							bool: {
								should: shouldQuery
							}
						}
					}
				},
				aggs: {
					histones: {
						terms: {
							field: 'protein_stable_id'
						},
						aggs: {
							analyses:{
								terms:{
									field: 'analysis_id'
								},
								aggs:{
									peak_size: {
										sum: {
											lang: "expression",
											script: "doc['chromosome_end'].value - doc['chromosome_start'].value + 1" 
										}
									}
								}
							}
						}
					}
				}
			}
		},function(err,resp) {
			if(typeof(resp.aggregations) !== undefined){	
				resp.aggregations.histones.buckets.forEach(function(d) {
					rangeData.stats.chipSeq.push(d);
				});
				deferred.resolve(localScope);
			} else {
				return deferred.reject(err); 
			}
		});
		
		return deferred.promise;
	};
	
	var getChartData = function(localScope,rangeData) {
		var deferred = $q.defer();
		var shouldQuery = genShouldQuery(rangeData.range);
		var cStart = rangeData.range.start;
		var cEnd = rangeData.range.end;
		var total = 0;
		//var totalPoints = 0;
		es.search({
			size: 5000,
			index: 'primary',
			scroll: '30s',
			body: {
				query: {
					filtered: {
						filter: {
							bool: {
								should: shouldQuery
							}
						}
					}
				},
				sort: [
					{
						chromosome_start: {
							order: "asc"
						}
					}
				]
			}
		}, function getMoreChartDataUntilDone(err, resp) {
			if(resp.hits!==undefined) {
				resp.hits.hits.forEach(function(segment) {
					if(segment._type in ConceptToChart) {
						var graph = rangeData[ConceptToChart[segment._type]];
						
						var analysis_id = segment._source.analysis_id;
						var seriesValues;
						if(analysis_id in graph.bpSideData.sampleToIndex) {
							seriesValues = graph.bpSideData.sampleToIndex[analysis_id];
						} else {
							seriesValues = [];
							var series = {
								values: seriesValues,
								key: analysis_id,
								//color:
							};
							graph.bpSideData.sampleToIndex[analysis_id] = seriesValues;
							graph.loadedData.push(series);
						}
						
						var value;
						switch(segment._type) {
							case PDNA_CONCEPT:
								value = segment._source.log10_qvalue;
								if(analysis_id.indexOf('_broad_')==-1) {
									value = -value;
								}
								break;
							case EXPG_CONCEPT:
								value = -segment._source.FPKM;
								break;
							case EXPT_CONCEPT:
								value = segment._source.FPKM;
								break;
							case DLAT_CONCEPT:
								value = segment._source.meth_level;
								if(analysis_id.indexOf('_hyper')==-1) {
									value = -value;
								}
								break;
							case RREG_CONCEPT:
								value = segment._source.z_score;
								break;
						}
						var chromosome_start = (cStart < segment._source.chromosome_start) ? segment._source.chromosome_start: cStart;
						var chromosome_end = (cEnd > segment._source.chromosome_end) ? segment._source.chromosome_end: cEnd;
						if(cStart<chromosome_start) {
							seriesValues.push([chromosome_start-1,null]);
						}
						seriesValues.push([chromosome_start,value]);
						if(chromosome_start!=chromosome_end) {
							seriesValues.push([chromosome_end, value]);
						}
						if(cEnd>chromosome_end) {
							seriesValues.push([chromosome_end+1, null]);
						}
						// totalPoints += segment._source.chromosome_end - segment._source.chromosome_start + 1;
					//} else {
						// Ignoring what we cannot process
					}
				});
				total += resp.hits.hits.length;
				
				if(resp.hits.total > total) {
					var percent = 100.0 * total / resp.hits.total;
					
					localScope.searchButtonText = "Loaded "+percent.toPrecision(2)+'%';
					
					//console.log("Hay "+total+' de '+resp.hits.total);
					es.scroll({
						scrollId: resp._scroll_id,
						scroll: '30s'
					}, getMoreChartDataUntilDone);
				} else {
					localScope.searchButtonText = SEARCHING_LABEL;
					es.clearScroll({scrollId: resp._scroll_id});
					
					GRAPHS.forEach(function(g) { 
						rangeData[g.name].data = rangeData[g.name].loadedData;
					});
					//console.log("Total: "+total+"; points: "+totalPoints);
					
					//console.log('All data ('+total+') was fetched');
					deferred.resolve(localScope);
				}
			} else {
				deferred.reject(err);
			}
		});
		
		return deferred.promise;
	};
	
	var getSamples = function(localScope) {
		if(localScope.samples.length!==0) {
			return localScope;
		}
		
		localScope.samples = [];
		localScope.samplesOnt = [];
		var deferred = $q.defer();
		es.search({
			index: 'sample-tracking-data',
			type: 'sdata.sample',
			size: 100000,
		},function(err,resp){
			if(typeof(resp.hits.hits) !== undefined) {
				resp.hits.hits.forEach(function(d) {
					var s = {};
					s.analyzed_sample_type_other = d._source.analyzed_sample_type_other;
					s.sample_id = d._source.sample_id;
					s.ontology = d._source.purified_cell_type;
					s.markers = d._source.markers;
					s.experiments = [];
					localScope.labs.forEach(function(d){
						if(d.sample_id == s.sample_id){
							s.experiments.push(d);
						}
					});
					localScope.samplesOnt.push(s.ontology);
					localScope.samples.push(s);
				});
				
				var numSamples = localScope.samples.length;
				
				localScope.subtotals.data.push({
						key: 'Samples',
						y: numSamples
					}
				);
				
				//console.log(localScope.samples);
				deferred.resolve(localScope);
			} else {
				return deferred.reject(err);
			}
		});
		return deferred.promise;
	};

	var getDonors = function(localScope) {
		if(localScope.donors.length!==0) {
			return localScope;
		}
		
		localScope.donors = [];
		return es.search({
			index: 'sample-tracking-data',
			type: 'sdata.donor',
			size: 100000,
		}).then(function(resp){
			if(typeof(resp.hits.hits) !== undefined) {
				var subtotalsData = [];
				
				var numDonors = 0;
				var numPooledDonors = 0;
				var numCellularLines = 0;
				var numOther = 0;
				resp.hits.hits.forEach(function(d) {
					switch(d._source.donor_kind) {
						case 'd':
							numDonors++;
							break;
						case 'p':
							numPooledDonors++;
							break;
						case 'c':
							numCellularLines++;
							break;
						default:
							numOther++;
					}
					localScope.donors.push(d._source);
				});
				subtotalsData.push({
						key: 'Donors',
						y: numDonors
					},
					{
						key: 'Cellular Lines',
						y: numCellularLines
					},
					{
						key: 'Pooled Donors',
						y: numPooledDonors
					}
				);
				
				if(numOther>0) {
					subtotalsData.push({
							key: 'Other kind of donors',
							y: numOther
						}
					);
				}
				
				localScope.subtotals.data = subtotalsData;
				//console.log(localScope.donors);
			}
			
			return localScope;
		});
	};
	
	var getSpecimens = function(localScope) {
		if(localScope.specimens.length!==0) {
			return localScope;
		}
		
		return es.search({
			index: 'sample-tracking-data',
			type: 'sdata.specimen',
			size: 100000,
		}).then(function(resp){
			if(typeof(resp.hits.hits) !== undefined) {
				resp.hits.hits.forEach(function(d) {
					localScope.specimens.push(d._source);
				});
				//console.log(localScope.specimens);
			}
			
			return localScope;
		});
	};

	var getHistoneStatsData = function(d,histone,stats,range){
		var exp = 0;
		var value = 0.0;
		var expB = 0;
		var valueB = 0.0;
		d.analyses.forEach(function(analysis_id){
		    var theValue = 0.0;
		    var theExp = 0;
		    stats.chipSeq.forEach(function(a){
		      if(a.key == histone){
			//console.log(a);
			a.analyses.buckets.forEach(function(c){
			  if(c.key == analysis_id){
			      theValue += parseFloat(c.peak_size.value);
			      theExp++;
			  }
			});
		      }
		    });
		    if(analysis_id.indexOf('_broad_')!==-1) {
		      expB += theExp;
		      valueB += theValue;
		    } else {
		      exp += theExp;
		      value += theValue;
		    }
		});
		
		// This can be a bit incorrect for pathways...
		if(exp > 0 || expB > 0) {
			var end = range.end+chipSeqWindow;
			var start = range.start-chipSeqWindow;
			// Corner case
			if(start < 1) {
				start=1;
			}
			var region = end - start + 1;
		  
			// console.log(region);
			if(exp > 0){
				//console.log(region);
				value = (value/region)*100.0;
			}
			if(expB > 0){
				valueB = (valueB/region)*100.0;
			}
		}
		return {notBroad:value, broad:valueB}; 
	};
	
	var populateBasicTree = function(o,localScope,range,stats,isDetailed) {
		var numNodes = 1;
		// First, the children
		if(o.children) {
			o.children.forEach(function(child) {
				numNodes += populateBasicTree(child,localScope,range,stats,isDetailed);
			});
		} else {
			o.children = [];
		}
		
		// And now, me!
		if(o.o_uri) {
			var aggregated_statistics = [];
			var childrens = [];
			localScope.experimentLabels.forEach(function() {
				aggregated_statistics.push(0);
				childrens.push(0);
			});
			localScope.samples.forEach(function(s) {
				if(s.ontology == o.o_uri) {
					o.analized = true;
					var statistics = [];
					localScope.experimentLabels.forEach(function() {
						statistics.push(0);
					});
					s.experiments.forEach(function(d){
						//console.log(d);
						var theStat = 0.0;
						if(d.experiment_type === 'DNA Methylation') {
							var methExp = 0;
							d.analyses.forEach(function(v) {
								stats.bisulfiteSeq.forEach(function(a) {
									if(a.key == v){
										theStat += a.stats_meth_level.avg;
										methExp++;
									}
								});
							});
							if(methExp > 0.0){
								theStat = theStat/methExp;
								childrens[0]++;
							} else {
								theStat = NaN;
							}
							statistics[0] = theStat;
						} else if(d.experiment_type === 'Chromatin Accessibility') {
							var dnaseSeqExp = 0;
							d.analyses.forEach(function(v) {
								stats.dnaseSeq.forEach(function(a) {
									if(a.key == v) {
										theStat += a.peak_size.value;
										dnaseSeqExp++;
									}
								});
							});
							if(dnaseSeqExp > 0) {
								var region = range.end - range.start + 1;
								theStat = theStat/region;
								childrens[1]++;
							} else {
								theStat = NaN;
							}
							statistics[1] = theStat;
						} else if(d.experiment_type === 'mRNA-seq') {
							// Expression at Gene and Transcript levels
							var rnaSeqExpG = 0;
							var rnaSeqExpT = 0;
							var theStatT = 0.0;
							
							d.analyses.forEach(function(v) {
								stats.rnaSeqG.forEach(function(a) {
									if(a.key == v) {
										theStat += a.stats_normalized_read_count.avg;
										rnaSeqExpG++;
									}
								});
								stats.rnaSeqT.forEach(function(a) {
									if(a.key == v) {
										theStatT += a.stats_normalized_read_count.avg;
										rnaSeqExpT++;
									}
								});
							});
							if(rnaSeqExpG > 0) {
								theStat = theStat/rnaSeqExpG;
								childrens[2]++;
							} else {
								theStat = NaN;
							}
							statistics[2] = theStat;
							
							if(rnaSeqExpT > 0) {
								theStatT = theStatT/rnaSeqExpT;
								childrens[3]++;
							} else {
								theStatT = NaN;
							}
							statistics[3] = theStatT;
						} else if(d.experiment_type.indexOf('Histone ')===0) {
							var normalizedHistone = d.features.CHIP_ANTIBODY.value.replace(/[.]/g,'_');
							
							if(normalizedHistone in localScope.histoneMap) {
								var expIdx = localScope.histoneMap[normalizedHistone];
								
								var histoneStats = getHistoneStatsData(d,normalizedHistone,stats,range);
								
								statistics[expIdx] = CSpeakSplit ? histoneStats.notBroad : (histoneStats.notBroad+histoneStats.broad);
								if(statistics[expIdx]>0) {
									childrens[expIdx]++;
								} else {
									statistics[expIdx] = NaN;
								}
									
								if(CSpeakSplit) {
									statistics[expIdx+1] = histoneStats.broad;
									if(statistics[expIdx+1]>0) {
										childrens[expIdx+1]++;
									} else {
										statistics[expIdx+1] = NaN;
									}
								}
							} else {
								console.log("Unmapped histone "+normalizedHistone);
							}
						}
					});
					
					// Translating to the right units
					if(!isNaN(statistics[0]) && statistics[0]!==-1) {
						statistics[0] *= 100.0;
					}
					
					if(!isNaN(statistics[1]) && statistics[1]!==-1) {
						statistics[1] *= 100.0;
					}
					
					statistics.forEach(function(stat,i) {
						if(!isNaN(stat) && stat!==-1) {
							aggregated_statistics[i] += stat;
						}
					});
					
					if(isDetailed){
						var newNode = {
							expData: statistics,
							name: s.sample_id,
							experimentsCount: s.experiments.length
						};
						
						o.children.push(newNode);
						numNodes++;
					}
				}
			});
			if(! o.expData) {
				//console.log(o[i]);
				var expData = [];
				aggregated_statistics.forEach(function(stat,i) {
					// Storing -1 for uninitialized cases
					expData.push((childrens[i] > 0)?(stat/childrens[i]):NaN);
				});
				o.expData = expData;
			}
		}
		return numNodes;
	};

	var initTree = function(localScope){
		console.log("initializing tree");
		
		if(Array.isArray(localScope)) {
			localScope = localScope[0];
		}
		
		lastSearchMode = localScope.display;
		if(lastSearchMode!=='none') {
			var isDetailed = lastSearchMode==='detailed';
			localScope.graphData.forEach(function(rangeData) {
				var clonedTreeData = angular.copy(fetchedTreeData);
				rangeData.treedata = [];
				clonedTreeData.forEach(function(cloned) {
					var numNodes = populateBasicTree(cloned,localScope,rangeData.range,rangeData.stats,isDetailed);
					rangeData.treedata.push({root: cloned, numNodes: numNodes, depth:(isDetailed?localScope.depth+1:localScope.depth), experiments: localScope.experimentLabels});
				});
			});
		}
	};

	var defaultSearchUri = 'http://www.ensembl.org/Human/Search/Results?site=ensembl;facet_species=Human;q=';
	var regionSearchUri = 'http://www.ensembl.org/Homo_sapiens/Location/View?r=';
	var searchUris = {
		gene: 'http://www.ensembl.org/Homo_sapiens/Gene/Summary?db=core&g=',
		pathway: 'http://www.reactome.org/content/detail/',
		transcript: 'http://www.ensembl.org/Homo_sapiens/Transcript/Summary?db=core&t=',
		reaction: 'http://www.reactome.org/content/detail/',
		region: regionSearchUri,
	};
	
	var updateChromosomes = function(localScope) {
		var tooMuch = localScope.rangeQuery.some(function(range) {
			return ((range.start>=range.end) || (range.end - range.start) > CHR_SEGMENT_LIMIT);
		});
		
		if(tooMuch) {
			window.alert("Some of the ranges is larger than "+CHR_SEGMENT_LIMIT+"bp");
			return false;
		}

		// First, let's update the query string
		var qString = ( localScope.currentQueryType !== 'range' ) ? localScope.currentQueryType + ':' + localScope.currentQuery : localScope.currentQuery;
		$location.search({q: qString});
		
		var regions = '';
		//localScope.chromosomes.forEach(function(d){
		//	d.c = "chr";
		//});
		// Now, let's prepare the backbones!
		localScope.graphData = [];
		localScope.rangeQuery.forEach(function(range,i) {
			console.log('Updating chromosome data '+range.chr);
			//localScope.chromosomes.forEach(function(d){
			//	if(d.n == range.chr) {
			//		d.c = "chr_active";
			//	}
			//});
			
			if(i>0) {
				regions += ' ; ';
			}
			var rangeStr = range.chr+":"+range.start+"-"+range.end;
			
			regions += "<a href='"+regionSearchUri+rangeStr+"' target='_blank'>chr"+rangeStr+"</a>";
			
			// Preparing the charts!
			var rangeData = {
				range: range,
				treedata: null,
				stats: {
					bisulfiteSeq: [],
					rnaSeqG: [],
					rnaSeqT: [],
					chipSeq: [],
					dnaseSeq: [],
				},
				gChro: localScope.unknownChromosome,
			};
			GRAPHS.forEach(function(gData) {
				rangeData[gData.name] = {
					options: {
						chart: {
							type: DATA_CHART_TYPE,
							height: DATA_CHART_HEIGHT,
							x: getXG,
							y: getYG,
							useInteractiveGuideline: true,
							noData: "Fetching "+gData.noData+" from "+rangeStr,
							showLegend: false,
							xAxis: {
								axisLabel: 'Coordinates (at chromosome '+range.chr+')'
							},
							yAxis: {
								axisLabel: gData.yAxisLabel
							}
						},
						title: {
							enable: true,
							text: gData.title
						},
					},
					data: [],
					loadedData: [],
					bpSideData: {
						sampleToIndex: {},
					},
				};
			});
			
			localScope.chromosomes.some(function(d){
				if(d.n == range.chr) {
					rangeData.gChro = d;
					return true;
				}
				return false;
			});
			
			localScope.graphData.push(rangeData);
		});
		localScope.found = "Displaying information from ";
		if(localScope.currentQueryType !== 'range') {
			var uri = (localScope.currentQueryType in searchUris) ? searchUris[localScope.currentQueryType] : defaultSearchUri;
			localScope.found += localScope.currentQueryType+" <a href='"+uri+localScope.ensemblGeneId+"' target='_blank'>"+localScope.currentQuery+" ["+localScope.ensemblGeneId+"]</a>, ";
		}
		localScope.found += "region"+((localScope.rangeQuery.length > 1)?'s':'')+": "+regions;
		
		return true;
	};
	
	var DEFAULT_QUERY_TYPES = ["gene","pathway","reaction"];
	
	var getRanges = function(localScope){
		var deferred = $q.defer();
		var queryTypes = localScope.currentQueryType!==undefined ? [localScope.currentQueryType] : DEFAULT_QUERY_TYPES;
		es.search({
			index: 'external',
			type: 'external.features',
			size: 1000,
			body: {
				query:{
					filtered:{
						query:{
							match: {
								symbol: localScope.currentQuery 
							}
						},
						filter: {
							terms: {
								feature: queryTypes
							}
						}
					}
				}
			}
		},function(err,resp){
			if(typeof(resp.hits.hits) !== undefined){
				localScope.ensemblGeneId = resp.hits.hits[0]._source.feature_cluster_id;
				localScope.currentQueryType = resp.hits.hits[0]._source.feature;
				resp.hits.hits[0]._source.coordinates.forEach(function(range) {
					localScope.rangeQuery.push({ chr: range.chromosome , start: range.chromosome_start, end: range.chromosome_end });
				});
				if(updateChromosomes(localScope)) {
					deferred.resolve(localScope);
				} else {
					deferred.reject('Coordinates range has been rejected, as it is too big');
				}
			} else {
				deferred.reject(err);
			}
		});
		return deferred.promise;
	};
    
	var fetchCellTerms = function(localScope) {
		if(fetchedTreeData!==undefined) {
			return localScope;
		}
		
		
		var deferred = $q.defer();
        
		// Let's calculate the unique terms
		var theUris=[];
		var theObj = {};
		localScope.samplesOnt.forEach(function(d) {
			if(!(d in theObj)) {
				theUris.push(d);
				theObj[d]=1;
			}
		});
		
		/*
		console.log("URIs");
		console.log(theUris);
		*/
		// Freeing the variable, as it is not needed, can cost time
		// theObj=undefined;
        
		es.search({
			index: 'meta-model',
			type: 'cvterm',
			size: 10000,
			body: {
				query: {
					filtered: {
						query: {
							match_all: {}
						},
						filter: {
							and: {
								filters: [{
									//term: {
									//	ont: 'cv:CellOntology'
									//}
									terms: {
										ont: ['cv:CellOntology','cv:EFO','cv:CellLineOntology']
									}
								},{
									terms: {
										alt_id: theUris
									}
								}]
							}
						}
					}
				},
				fields: ['term','ancestors']
			}
		}, function(err,resp) {
			if(resp.hits.total > 0) {
				// Let's gather all the distinct terms
				var theTerms = [];
				var theTermsHash = {};
				
				var theExtendedTerms = [];
				var theExtendedTermsHash = {};
				
				var maxDepth=0;
				resp.hits.hits.forEach(function(v) {
					var d = v.fields;
					var theTerm = d.term[0];
					if(!(theTerm in theTermsHash)) {
						theTerms.push(theTerm);
						theTermsHash[theTerm] = null;

						if(!(theTerm in theExtendedTermsHash)) {
							theExtendedTerms.push(theTerm);
							theExtendedTermsHash[theTerm]=null;
						}
						// There could be terms without ancestors
						var depth = 1;
						if(d.ancestors) {
							depth += d.ancestors.length;

							d.ancestors.forEach(function(term) {
								if(!(term in theExtendedTermsHash)) {
									theExtendedTerms.push(term);
									theExtendedTermsHash[term]=null;
								}
							});
						}
						if(depth > maxDepth) {
							maxDepth = depth;
						}
					}
				});
				localScope.depth = maxDepth;
				
				/*
				console.log("Terms");
				console.log(theTerms);
				*/
				
				// Now, send the query to fetch all of them
				es.search({
					index: 'meta-model',
					type: 'cvterm',
					size: 10000,
					body: {
						query: {
							filtered: {
								query: {
									match_all: {}
								},
								filter: {
									terms: {
										term: theExtendedTerms
									}
								}
							}
						},
						fields: ['term','term_uri','name','parents']
					}
				}, function(err, resp) {
					if(resp.hits.total > 0) {
						// And rebuild the tree!
						var fetchedNodes = {};
						var treeNodes = {};
						
						// Roots are the nodes with no parent
						var roots = [];
						
						// First pass, the nodes
						resp.hits.hits.forEach(function(v) {
							var n = v.fields;
							treeNodes[n.term[0]] = {
								name: n.name[0],
								o: n.term[0],
								o_uri: n.term_uri[0]
							};
							
							fetchedNodes[n.term[0]] = n;
						});
						/*
						console.log("Extended terms");
						console.log(theExtendedTerms);
						console.log("Fetched Nodes");
						console.log(fetchedNodes);
						console.log("Tree Nodes");
						console.log(treeNodes);
						*/
						
						// Second pass, the parent-child relationships
						for(var theTerm in fetchedNodes) {
							var n = fetchedNodes[theTerm];
							var tn = treeNodes[theTerm];
							if(! tn.visited) {
								if(n.parents) {
									var added = 0;
									n.parents.forEach(function(p) {
										// Skipping multi-parenting cases, to artificially prune the DAG into a tree
										if(p in treeNodes) {
											var ptn = treeNodes[p];
											if(added===0) {
												if(! ptn.children) {
													ptn.children = [];
												}
												
												ptn.children.push(tn);
											} else {
												if(! ptn.links) {
													ptn.links = [];
												}
												
												ptn.links.push(tn);
											}
											added++;
										}
									});
								} else {
									// This is a root
									roots.push(tn);
								}
								tn.visited = true;
							}
						}
						
						// Due the artificial translation into a tree, there are many dead branches
						// Now, let's see the involved nodes
						var nowNodes = [].concat(roots);
						var leafDeadNodes = [];
						while(nowNodes.length > 0) {
						 	var nextNodes = [];
						 	nowNodes.forEach(function(t) {
						 		if(t.children && t.children.length > 0) {
						 			nextNodes = nextNodes.concat(t.children);
						 		} else if(!(t.o in theTermsHash)) {
									leafDeadNodes.push(t);
								}
						 	});
						 	nowNodes = nextNodes;
						}
						
						// And let's prune the tree
						var rounds = 0;
						while(leafDeadNodes.length > 0) {
							// Debugging
							/*
							var lonames = [];
							var loterms = [];
							leafDeadNodes.forEach(function(lo) {
								lonames.push(lo.name);
								loterms.push(lo.o);
							});
							console.log("Round "+rounds);
							console.log(lonames);
							console.log(loterms);
							*/
							rounds++;
                                                        
                                                        // Now, remove the dead nodes
							var nextDeadNodes = [];
							leafDeadNodes.forEach(function(lo) {
								var l = fetchedNodes[lo.o];
								l.parents.some(function(po) {
									if(po in treeNodes) {
										var p=treeNodes[po];
										if(p.children && p.children.length>0) {
											var pl=-1;
											p.children.some(function(child,iCh) {
												if(child.o==lo.o) {
													pl=iCh;
													return true;
												}
												return false;
											});
											if(pl!==-1) {
												p.children.splice(pl,1);
												if(!(p.o in theTermsHash) && p.children.length===0) {
													delete(p.children);
													nextDeadNodes.push(p);
												}
											/*
											} else {
												console.log("Raro "+lo.o);
												console.log(p);
											*/
											}
										}
										return true;
									}
									return false;
								});
							});
							leafDeadNodes = nextDeadNodes;
						}
						
						// Sort by root uri
						fetchedTreeData = roots.sort(function(a,b) { return a.o_uri.localeCompare(b.o_uri); });
						deferred.resolve(localScope);
					} else {
						return deferred.reject(err);
					}
				});
			} else {
				return deferred.reject(err);
			}
		});
		return deferred.promise;
	};

	var topFeatures = {
		'gene': null,
		'reaction': null,
		'pathway': null
	};

	var my_feature_ranking = {
		gene: 1,
		pathway: 2,
		transcript: 3,
		exon: 4,
		reaction: 5,
		CDS: 6,
		UTR: 7,
		start_codon: 8,
		stop_codon: 9,
		Selenocysteine: 10
	};
	
	var preprocessQuery = function(localScope) {
		console.log('Running preprocessQuery');
		var deferred = $q.defer();
		var promise = deferred.promise;
		var acceptedUpdate=true;
		
		if(localScope.suggestedQuery) {
			localScope.ensemblGeneId = localScope.suggestedQuery.feature_cluster_id;
			localScope.currentQuery = localScope.suggestedQuery.term;
			localScope.currentQueryType = localScope.suggestedQuery.feature;
			if(!(localScope.suggestedQuery.feature in topFeatures)) {
				localScope.currentQueryType += ' from gene,';
			}
			localScope.suggestedQuery.coordinates.forEach(function(range) {
				localScope.rangeQuery.push({ chr: range.chromosome , start: range.chromosome_start, end: range.chromosome_end });
			});
			acceptedUpdate = updateChromosomes(localScope);
		} else {
			var q = localScope.query.trim();
			var queryType;
			var colonPos = q.indexOf(':');
			var m;
			if(colonPos!==-1) {
				var possibleQueryType = q.substring(0,colonPos);
				if(possibleQueryType in my_feature_ranking) {
					queryType = possibleQueryType;
					q = q.substring(colonPos+1);
				} else {
					m = q.match('^(?:chr)?([^:-]+):([1-9][0-9]*)-([1-9][0-9]*)$');
				}
			}
			
			//range query
			localScope.currentQuery = q;
			if(m) {
				if(m[1] === 'M') {
					// Normalizing mitochondrial chromosome name
					m[1] = 'MT';
				}
				localScope.rangeQuery.push({chr: m[1], start: m[2], end: m[3]});
				localScope.currentQueryType = 'range';
				// localScope.rangeQuery.chr   = m[1];
				// localScope.rangeQuery.start = m[2];
				// localScope.rangeQuery.end   = m[3];
				// localScope.found = "Displaying information from region: chr"+localScope.rangeQuery[0].chr+":"+localScope.rangeQuery[0].start+"-"+localScope.rangeQuery[0].end;
				acceptedUpdate = updateChromosomes(localScope);
			} else {
				localScope.currentQueryType = queryType;
				promise = promise.then(getRanges);
			}
		}
		
		if(acceptedUpdate) {
			deferred.resolve(localScope);
		} else {
			deferred.reject('Coordinates range has been rejected, as it is too big');
		}
		
		return promise;
	};

    $scope.resultsSearch = [];
    
	$scope.search = function(theSuggest){
		if(!$scope.queryInProgress) {
			$scope.queryInProgress = true;
			$scope.found = "";
			$scope.suggestedQuery = theSuggest;
			$scope.resultsSearch = [];
			
			$scope.rangeQuery = [];
			$scope.ensemblGeneId = null;
			$scope.currentQuery = null;
			$scope.currentQueryType = null;
			
			$scope.searchButtonText = SEARCHING_LABEL;

			var deferred = $q.defer();
			var promise = deferred.promise;
			promise = promise.then(preprocessQuery)
				.then(launch(getChartData))
				// Either the browser or the server gets too stressed with this concurrent query
				//.then($q.all([launch(getWgbsData),launch(getRnaSeqGData),launch(getRnaSeqTData),launch(getChipSeqData),launch(getDnaseData)]))
				.then(launch(getWgbsStatsData))
				.then(launch(getRnaSeqGStatsData))
				.then(launch(getRnaSeqTStatsData))
				.then(launch(getChipSeqStatsData))
				.then(launch(getDnaseStatsData))
				.then(initTree)
				.finally(function() {
					$scope.queryInProgress = false;
					$scope.searchButtonText = SEARCH_LABEL;
				});
				 
			deferred.resolve($scope);
		}
	};
	
	$scope.suggest = function() {
		if(!$scope.suggestInProgress) {
			$scope.resultsSearch = [];
			$scope.suggestedQuery = null;
			
			var query = $scope.query.trim().toLowerCase();
			var queryType;
			var colonPos = query.indexOf(':');
			if(colonPos!==-1) {
				queryType = query.substring(0,colonPos);
				query = query.substring(colonPos+1);
			}
			
			if(query.length >= 3 && (!queryType || (queryType in my_feature_ranking))) {
				$scope.suggestInProgress = true;
				var deferred = $q.defer();
				var promise = deferred.promise;
				promise.finally(function() {
					$scope.suggestInProgress = false;
				});
				
				//query = query.toLowerCase();
				var theFilter = {
					prefix: {
						symbol: query
					}
				};
				var sugLimit;
				if(queryType) {
					theFilter = {
						bool: {
							must: [
								{
									term: {
										feature: queryType
									}
								},
								theFilter
							]
						}
					};
					sugLimit = 20;
				} else {
					sugLimit = 4;
				}
				es.search({
					index: 'external',
					type: 'external.features',
					size: 5000,
					body: {
						query:{
							filtered: {
								query: {
									match_all: {}
								},
								filter: theFilter
							}
						},
					}
				},function(err,resp){
					var resultsSearch = [];
					
					resp.hits.hits.forEach(function(sug,i) {
						var theTerm;
						var theSecondTerm;
						var isFirst = 0;
						
						sug._source.symbol.forEach(function(term) {
							var termpos = term.toLowerCase().indexOf(query);
							if(termpos===0) {
								if(theTerm===undefined || term.length < theTerm.length) {
									theTerm = term;
								}
							} else if(termpos!==-1) {
								if(theSecondTerm===undefined || term.length < theSecondTerm.length) {
									theSecondTerm = term;
								}
							}
						});
						
						// A backup default
						if(theTerm===undefined) {
							if(theSecondTerm !== undefined) {
								isFirst = 1;
								theTerm = theSecondTerm;
							} else {
								isFirst = 2;
								theTerm = sug._source.symbol[0];
							}
						}
						var feature = sug._source.feature;
						var featureScore = (feature in my_feature_ranking) ? my_feature_ranking[feature] : 255;
						resultsSearch.push({term:theTerm, pos:i, isFirst: isFirst, fullTerm: theTerm+' ('+sug._source.symbol.join(", ")+')', id:sug._id, coordinates:sug._source.coordinates, feature:feature,featureScore:featureScore, feature_cluster_id:sug._source.feature_cluster_id});
					});
					
					resultsSearch.sort(function(a,b) {
						if(a.featureScore != b.featureScore) {
							return a.featureScore - b.featureScore;
						} else if(a.isFirst != b.isFirst) {
							return a.isFirst - b.isFirst;
						} else if(a.term.length != b.term.length) {
							return a.term.length - b.term.length;
						} else {
							return a.term.localeCompare(b.term);
						}
					});
					
					var curFeat = '';
					var numFeat = 0;
					resultsSearch.forEach(function(r) {
						if(r.feature != curFeat) {
							curFeat = r.feature;
							numFeat = 0;
						}
						if(numFeat<sugLimit) {
							$scope.resultsSearch.push(r);
							numFeat++;
						}
					});
					
					deferred.resolve();
				});
			}
		}
	};
	
	$scope.enterSearch = function(keyEvent) {
		if(!$scope.suggestInProgress && keyEvent.which === 13 && $scope.query.length > 0) {
			//if($scope.resultsSearch.length > 0) {
			//	$scope.search($scope.resultsSearch[0]);
			//} else {
				$scope.search();
			//}
		}
	};

	var init = function($q) {
		var deferred = $q.defer();
		var promise = deferred.promise;
		promise = promise.then(function(localScope) { return $q.all([getDonors(localScope),getSpecimens(localScope),getAnalyses(localScope)]); })
				.then(getLabs)
				.then(getSamples)
				.then(fetchCellTerms);
		
		if('q' in $location.search()) {
			var query = $location.search().q;
			promise = promise.then(function(localScope) {
				localScope.query = query;
				localScope.search();
			});
		}
		
		deferred.resolve($scope);
		$scope.$on('$locationChangeStart', function(event) {
			//console.log("He visto algo");
			if($scope.searchInProgress) {
				event.preventDefault();
			}
		});
		$scope.$on('$locationChangeSuccess', function(event) {
			//console.log("Lo vi!!!!!");
			if('q' in $location.search()) {
				var query = $location.search().q;
				$scope.query = query;
				$scope.search();
			}
		});
	};
	
	init($q);
}]);
